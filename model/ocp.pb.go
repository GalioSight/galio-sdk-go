// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ocp.proto

package model

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TelemetryData 数据类型。
type TelemetryData int32

const (
	TelemetryData_TELEMETRY_DATA_INVALID  TelemetryData = 0
	TelemetryData_TELEMETRY_DATA_METRICS  TelemetryData = 1
	TelemetryData_TELEMETRY_DATA_LOGS     TelemetryData = 2
	TelemetryData_TELEMETRY_DATA_TRACES   TelemetryData = 3
	TelemetryData_TELEMETRY_DATA_PROFILES TelemetryData = 4
)

var TelemetryData_name = map[int32]string{
	0: "TELEMETRY_DATA_INVALID",
	1: "TELEMETRY_DATA_METRICS",
	2: "TELEMETRY_DATA_LOGS",
	3: "TELEMETRY_DATA_TRACES",
	4: "TELEMETRY_DATA_PROFILES",
}

var TelemetryData_value = map[string]int32{
	"TELEMETRY_DATA_INVALID":  0,
	"TELEMETRY_DATA_METRICS":  1,
	"TELEMETRY_DATA_LOGS":     2,
	"TELEMETRY_DATA_TRACES":   3,
	"TELEMETRY_DATA_PROFILES": 4,
}

func (x TelemetryData) String() string {
	return proto.EnumName(TelemetryData_name, int32(x))
}

func (TelemetryData) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{0}
}

// DataProtocol 数据协议。
type DataProtocol int32

const (
	DataProtocol_DATA_PROTOCOL_INVALID    DataProtocol = 0
	DataProtocol_DATA_PROTOCOL_OTLP       DataProtocol = 1
	DataProtocol_DATA_PROTOCOL_PROMETHEUS DataProtocol = 2
	DataProtocol_DATA_PROTOCOL_JAEGER     DataProtocol = 3
	DataProtocol_DATA_PROTOCOL_M007       DataProtocol = 4
	DataProtocol_DATA_PROTOCOL_OTP        DataProtocol = 5
)

var DataProtocol_name = map[int32]string{
	0: "DATA_PROTOCOL_INVALID",
	1: "DATA_PROTOCOL_OTLP",
	2: "DATA_PROTOCOL_PROMETHEUS",
	3: "DATA_PROTOCOL_JAEGER",
	4: "DATA_PROTOCOL_M007",
	5: "DATA_PROTOCOL_OTP",
}

var DataProtocol_value = map[string]int32{
	"DATA_PROTOCOL_INVALID":    0,
	"DATA_PROTOCOL_OTLP":       1,
	"DATA_PROTOCOL_PROMETHEUS": 2,
	"DATA_PROTOCOL_JAEGER":     3,
	"DATA_PROTOCOL_M007":       4,
	"DATA_PROTOCOL_OTP":        5,
}

func (x DataProtocol) String() string {
	return proto.EnumName(DataProtocol_name, int32(x))
}

func (DataProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{1}
}

// DataTransmission 数据传输方式。
type DataTransmission int32

const (
	DataTransmission_DATA_TRANSMISSION_INVALID DataTransmission = 0
	DataTransmission_DATA_TRANSMISSION_HTTP    DataTransmission = 1
	DataTransmission_DATA_TRANSMISSION_gRPC    DataTransmission = 2
	DataTransmission_DATA_TRANSMISSION_tRPC    DataTransmission = 3
)

var DataTransmission_name = map[int32]string{
	0: "DATA_TRANSMISSION_INVALID",
	1: "DATA_TRANSMISSION_HTTP",
	2: "DATA_TRANSMISSION_gRPC",
	3: "DATA_TRANSMISSION_tRPC",
}

var DataTransmission_value = map[string]int32{
	"DATA_TRANSMISSION_INVALID": 0,
	"DATA_TRANSMISSION_HTTP":    1,
	"DATA_TRANSMISSION_gRPC":    2,
	"DATA_TRANSMISSION_tRPC":    3,
}

func (x DataTransmission) String() string {
	return proto.EnumName(DataTransmission_name, int32(x))
}

func (DataTransmission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{2}
}

// MetricsSampleType 指标采样方式。
type MetricsSampleType int32

const (
	MetricsSampleType_METRICS_SAMPLE_TYPE_INVALID MetricsSampleType = 0
	MetricsSampleType_METRICS_SAMPLE_TYPE_RAND    MetricsSampleType = 1
	MetricsSampleType_METRICS_SAMPLE_TYPE_ROWS    MetricsSampleType = 2
)

var MetricsSampleType_name = map[int32]string{
	0: "METRICS_SAMPLE_TYPE_INVALID",
	1: "METRICS_SAMPLE_TYPE_RAND",
	2: "METRICS_SAMPLE_TYPE_ROWS",
}

var MetricsSampleType_value = map[string]int32{
	"METRICS_SAMPLE_TYPE_INVALID": 0,
	"METRICS_SAMPLE_TYPE_RAND":    1,
	"METRICS_SAMPLE_TYPE_ROWS":    2,
}

func (x MetricsSampleType) String() string {
	return proto.EnumName(MetricsSampleType_name, int32(x))
}

func (MetricsSampleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{3}
}

// 枚举接入点
type AccessPoint int32

const (
	AccessPoint_ACCESS_POINT_INVALID    AccessPoint = 0
	AccessPoint_ACCESS_POINT_SG_PUBLIC  AccessPoint = 1
	AccessPoint_ACCESS_POINT_SG_PRIVATE AccessPoint = 2
	AccessPoint_ACCESS_POINT_CN_PUBLIC  AccessPoint = 3
	AccessPoint_ACCESS_POINT_CN_PRIVATE AccessPoint = 4
)

var AccessPoint_name = map[int32]string{
	0: "ACCESS_POINT_INVALID",
	1: "ACCESS_POINT_SG_PUBLIC",
	2: "ACCESS_POINT_SG_PRIVATE",
	3: "ACCESS_POINT_CN_PUBLIC",
	4: "ACCESS_POINT_CN_PRIVATE",
}

var AccessPoint_value = map[string]int32{
	"ACCESS_POINT_INVALID":    0,
	"ACCESS_POINT_SG_PUBLIC":  1,
	"ACCESS_POINT_SG_PRIVATE": 2,
	"ACCESS_POINT_CN_PUBLIC":  3,
	"ACCESS_POINT_CN_PRIVATE": 4,
}

func (x AccessPoint) String() string {
	return proto.EnumName(AccessPoint_name, int32(x))
}

func (AccessPoint) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{4}
}

// Collector 数据收集服务器信息。
type Collector struct {
	// collector 地址，通常是 ias 域名代理服务地址。
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr" yaml:"addr"`
	// TelemetryData 数据类型
	TelemetryData TelemetryData `protobuf:"varint,2,opt,name=telemetry_data,json=telemetryData,proto3,enum=model.TelemetryData" json:"telemetry_data" yaml:"telemetry_data"`
	// DataProtocol 数据协议
	DataProtocol DataProtocol `protobuf:"varint,3,opt,name=data_protocol,json=dataProtocol,proto3,enum=model.DataProtocol" json:"data_protocol" yaml:"data_protocol"`
	// DataTransmission 数据传输方式
	DataTransmission DataTransmission `protobuf:"varint,4,opt,name=data_transmission,json=dataTransmission,proto3,enum=model.DataTransmission" json:"data_transmission" yaml:"data_transmission"`
	// 版本号，默认 0
	Version int32 `protobuf:"varint,5,opt,name=version,proto3" json:"version" yaml:"version"`
	// DirectIpPort 直连 ip:port。
	// 当网络畅通，可以直连时，上报数据可以不经过域名代理服务，以减轻 ias 的压力。
	// 同时也可以减少对外部系统的依赖，避免 ias 故障时，监控受影响。
	DirectIpPort []string `protobuf:"bytes,6,rep,name=direct_ip_port,json=directIpPort,proto3" json:"direct_ip_port" yaml:"direct_ip_port"`
}

func (m *Collector) Reset()         { *m = Collector{} }
func (m *Collector) String() string { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()    {}
func (*Collector) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{0}
}
func (m *Collector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Collector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Collector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Collector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Collector.Merge(m, src)
}
func (m *Collector) XXX_Size() int {
	return m.Size()
}
func (m *Collector) XXX_DiscardUnknown() {
	xxx_messageInfo_Collector.DiscardUnknown(m)
}

var xxx_messageInfo_Collector proto.InternalMessageInfo

func (m *Collector) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *Collector) GetTelemetryData() TelemetryData {
	if m != nil {
		return m.TelemetryData
	}
	return TelemetryData_TELEMETRY_DATA_INVALID
}

func (m *Collector) GetDataProtocol() DataProtocol {
	if m != nil {
		return m.DataProtocol
	}
	return DataProtocol_DATA_PROTOCOL_INVALID
}

func (m *Collector) GetDataTransmission() DataTransmission {
	if m != nil {
		return m.DataTransmission
	}
	return DataTransmission_DATA_TRANSMISSION_INVALID
}

func (m *Collector) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Collector) GetDirectIpPort() []string {
	if m != nil {
		return m.DirectIpPort
	}
	return nil
}

// GetConfigRequest 一般观测对象配置请求。
// 请求 Post /ocp/api/v1/get_config
// target 是 omp 和 ocp 的核心概念之一，任何观测数据，都必须绑定到一个 target
// 上。target 是观测对象的唯一标识 ID，必须全局唯一，target
// 相同，就认为是同一个对象。target
// 必须全局唯一，为了避免冲突，格式上分为两部分，用点分割。
// 第一部分是平台（platform），第二部分是平台内的对象名称（object_name）。
// 第一个点之前的部分，是 platform，如 PCG-123，不同平台的 platform 是不同的。
// 第一个点之后的部分，是 object_name，如 galileo.metaserver。
// target = platform . object_name
type GetConfigRequest struct {
	// 观测对象所在的平台，如 PCG-123, STKE
	Platform string `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform" yaml:"platform"`
	// 观测对象名，需要在$platform 下唯一，如 m007.metadata
	ObjectName string `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name" yaml:"object_name"`
	// SDK 支持的 metrics 协议
	Metrics CollectorProtocol `protobuf:"bytes,3,opt,name=metrics,proto3" json:"metrics" yaml:"metrics"`
	// SDK 支持的 traces 协议
	Traces CollectorProtocol `protobuf:"bytes,4,opt,name=traces,proto3" json:"traces" yaml:"traces"`
	// SDK 支持的 logs 协议
	Logs CollectorProtocol `protobuf:"bytes,5,opt,name=logs,proto3" json:"logs" yaml:"logs"`
	// 环境，一般不需要填
	Env string `protobuf:"bytes,6,opt,name=env,proto3" json:"env" yaml:"env"`
	// set 部署时的 set 名，一般不需要填
	Set string `protobuf:"bytes,7,opt,name=set,proto3" json:"set" yaml:"set"`
	// Resource 资源对象，里面的字段是可选的，在能取到的情况下需要传到 OCP 服务。
	Resource Resource `protobuf:"bytes,8,opt,name=resource,proto3" json:"resource" yaml:"resource"`
	// SDK 支持的 profiles 协议
	Profiles CollectorProtocol `protobuf:"bytes,9,opt,name=profiles,proto3" json:"profiles" yaml:"profiles"`
	// 上传本地配置（可选）
	Local *GetConfigResponse `protobuf:"bytes,10,opt,name=local,proto3" json:"local" yaml:"local"`
}

func (m *GetConfigRequest) Reset()         { *m = GetConfigRequest{} }
func (m *GetConfigRequest) String() string { return proto.CompactTextString(m) }
func (*GetConfigRequest) ProtoMessage()    {}
func (*GetConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{1}
}
func (m *GetConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigRequest.Merge(m, src)
}
func (m *GetConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigRequest proto.InternalMessageInfo

func (m *GetConfigRequest) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *GetConfigRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *GetConfigRequest) GetMetrics() CollectorProtocol {
	if m != nil {
		return m.Metrics
	}
	return CollectorProtocol{}
}

func (m *GetConfigRequest) GetTraces() CollectorProtocol {
	if m != nil {
		return m.Traces
	}
	return CollectorProtocol{}
}

func (m *GetConfigRequest) GetLogs() CollectorProtocol {
	if m != nil {
		return m.Logs
	}
	return CollectorProtocol{}
}

func (m *GetConfigRequest) GetEnv() string {
	if m != nil {
		return m.Env
	}
	return ""
}

func (m *GetConfigRequest) GetSet() string {
	if m != nil {
		return m.Set
	}
	return ""
}

func (m *GetConfigRequest) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource{}
}

func (m *GetConfigRequest) GetProfiles() CollectorProtocol {
	if m != nil {
		return m.Profiles
	}
	return CollectorProtocol{}
}

func (m *GetConfigRequest) GetLocal() *GetConfigResponse {
	if m != nil {
		return m.Local
	}
	return nil
}

// CollectorProtocol SDK 支持的协议。
type CollectorProtocol struct {
	// 数据类型，如 TELEMETRY_DATA_METRICS
	TelemetryData TelemetryData `protobuf:"varint,2,opt,name=telemetry_data,json=telemetryData,proto3,enum=model.TelemetryData" json:"telemetry_data" yaml:"telemetry_data"`
	// 数据协议，如 DATA_PROTOCOL_OTP
	DataProtocol DataProtocol `protobuf:"varint,3,opt,name=data_protocol,json=dataProtocol,proto3,enum=model.DataProtocol" json:"data_protocol" yaml:"data_protocol"`
	// 数据传输方式，如 DATA_TRANSMISSION_HTTP
	DataTransmission DataTransmission `protobuf:"varint,4,opt,name=data_transmission,json=dataTransmission,proto3,enum=model.DataTransmission" json:"data_transmission" yaml:"data_transmission"`
	// 版本号，默认 0
	Version int32 `protobuf:"varint,5,opt,name=version,proto3" json:"version" yaml:"version"`
}

func (m *CollectorProtocol) Reset()         { *m = CollectorProtocol{} }
func (m *CollectorProtocol) String() string { return proto.CompactTextString(m) }
func (*CollectorProtocol) ProtoMessage()    {}
func (*CollectorProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{2}
}
func (m *CollectorProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollectorProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollectorProtocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollectorProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollectorProtocol.Merge(m, src)
}
func (m *CollectorProtocol) XXX_Size() int {
	return m.Size()
}
func (m *CollectorProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_CollectorProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_CollectorProtocol proto.InternalMessageInfo

func (m *CollectorProtocol) GetTelemetryData() TelemetryData {
	if m != nil {
		return m.TelemetryData
	}
	return TelemetryData_TELEMETRY_DATA_INVALID
}

func (m *CollectorProtocol) GetDataProtocol() DataProtocol {
	if m != nil {
		return m.DataProtocol
	}
	return DataProtocol_DATA_PROTOCOL_INVALID
}

func (m *CollectorProtocol) GetDataTransmission() DataTransmission {
	if m != nil {
		return m.DataTransmission
	}
	return DataTransmission_DATA_TRANSMISSION_INVALID
}

func (m *CollectorProtocol) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// GetConfigResponse 一般观测对象配置响应。
type GetConfigResponse struct {
	// 返回码
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code" yaml:"code"`
	// 返回信息
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg" yaml:"msg"`
	// 观测目标，=$platform.$object_name, 与请求参数对应，主要用于调试
	Target string `protobuf:"bytes,3,opt,name=target,proto3" json:"target" yaml:"target"`
	// config server 地址，用于 schema 上报，新版本已经不再使用
	ConfigServer string `protobuf:"bytes,4,opt,name=config_server,json=configServer,proto3" json:"config_server" yaml:"config_server"`
	// register server 地址，为 v0.1.x 版本设计 prometheus 注册地址，现在 v0.1 版本已经无人使用
	RegisterServer string `protobuf:"bytes,5,opt,name=register_server,json=registerServer,proto3" json:"register_server" yaml:"register_server"`
	// 自监控配置
	SelfMonitor SelfMonitor `protobuf:"bytes,6,opt,name=self_monitor,json=selfMonitor,proto3" json:"self_monitor" yaml:"self_monitor"`
	// 指标相关配置。
	MetricsConfig MetricsConfig `protobuf:"bytes,7,opt,name=metrics_config,json=metricsConfig,proto3" json:"metrics_config" yaml:"metrics_config"`
	// 追踪相关配置。
	TracesConfig TracesConfig `protobuf:"bytes,8,opt,name=traces_config,json=tracesConfig,proto3" json:"traces_config" yaml:"traces_config"`
	// 日志相关配置。
	LogsConfig LogsConfig `protobuf:"bytes,9,opt,name=logs_config,json=logsConfig,proto3" json:"logs_config" yaml:"logs_config"`
	// tenant_id 租户 id，由后台自动分配。现在 traces 和 logs 依赖于正确的租户 id
	// 才能写入数据。
	TenantId string `protobuf:"bytes,10,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id" yaml:"tenant_id"`
	// version 服务配置，默认 0，0：本地配置优先，1：远程配置优先。
	Version int32 `protobuf:"varint,11,opt,name=version,proto3" json:"version" yaml:"version"`
	// 性能相关配置。
	ProfilesConfig ProfilesConfig `protobuf:"bytes,12,opt,name=profiles_config,json=profilesConfig,proto3" json:"profiles_config" yaml:"profiles_config"`
	// 接入点
	AccessPoint AccessPoint `protobuf:"varint,13,opt,name=access_point,json=accessPoint,proto3,enum=model.AccessPoint" json:"access_point" yaml:"access_point"`
	// prometheus push 配置
	PrometheusPush PrometheusPushConfig `protobuf:"bytes,14,opt,name=prometheus_push,json=prometheusPush,proto3" json:"prometheus_push" yaml:"prometheus_push"`
	// OpenTelemetry push 配置
	OpentelemetryPush OpenTelemetryPushConfig `protobuf:"bytes,15,opt,name=opentelemetry_push,json=opentelemetryPush,proto3" json:"opentelemetry_push" yaml:"opentelemetry_push"`
}

func (m *GetConfigResponse) Reset()         { *m = GetConfigResponse{} }
func (m *GetConfigResponse) String() string { return proto.CompactTextString(m) }
func (*GetConfigResponse) ProtoMessage()    {}
func (*GetConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{3}
}
func (m *GetConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigResponse.Merge(m, src)
}
func (m *GetConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigResponse proto.InternalMessageInfo

func (m *GetConfigResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetConfigResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *GetConfigResponse) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *GetConfigResponse) GetConfigServer() string {
	if m != nil {
		return m.ConfigServer
	}
	return ""
}

func (m *GetConfigResponse) GetRegisterServer() string {
	if m != nil {
		return m.RegisterServer
	}
	return ""
}

func (m *GetConfigResponse) GetSelfMonitor() SelfMonitor {
	if m != nil {
		return m.SelfMonitor
	}
	return SelfMonitor{}
}

func (m *GetConfigResponse) GetMetricsConfig() MetricsConfig {
	if m != nil {
		return m.MetricsConfig
	}
	return MetricsConfig{}
}

func (m *GetConfigResponse) GetTracesConfig() TracesConfig {
	if m != nil {
		return m.TracesConfig
	}
	return TracesConfig{}
}

func (m *GetConfigResponse) GetLogsConfig() LogsConfig {
	if m != nil {
		return m.LogsConfig
	}
	return LogsConfig{}
}

func (m *GetConfigResponse) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *GetConfigResponse) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetConfigResponse) GetProfilesConfig() ProfilesConfig {
	if m != nil {
		return m.ProfilesConfig
	}
	return ProfilesConfig{}
}

func (m *GetConfigResponse) GetAccessPoint() AccessPoint {
	if m != nil {
		return m.AccessPoint
	}
	return AccessPoint_ACCESS_POINT_INVALID
}

func (m *GetConfigResponse) GetPrometheusPush() PrometheusPushConfig {
	if m != nil {
		return m.PrometheusPush
	}
	return PrometheusPushConfig{}
}

func (m *GetConfigResponse) GetOpentelemetryPush() OpenTelemetryPushConfig {
	if m != nil {
		return m.OpentelemetryPush
	}
	return OpenTelemetryPushConfig{}
}

// SelfMonitor 自监控配置。
type SelfMonitor struct {
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// CollectorAddr 自监控数据收集地址，和数据的收集地址会做集群上的隔离。
	Collector Collector `protobuf:"bytes,2,opt,name=collector,proto3" json:"collector" yaml:"collector"`
	// 自监控数据的上报间隔
	ReportSeconds int32 `protobuf:"varint,3,opt,name=report_seconds,json=reportSeconds,proto3" json:"report_seconds" yaml:"report_seconds"`
}

func (m *SelfMonitor) Reset()         { *m = SelfMonitor{} }
func (m *SelfMonitor) String() string { return proto.CompactTextString(m) }
func (*SelfMonitor) ProtoMessage()    {}
func (*SelfMonitor) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{4}
}
func (m *SelfMonitor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SelfMonitor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SelfMonitor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SelfMonitor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SelfMonitor.Merge(m, src)
}
func (m *SelfMonitor) XXX_Size() int {
	return m.Size()
}
func (m *SelfMonitor) XXX_DiscardUnknown() {
	xxx_messageInfo_SelfMonitor.DiscardUnknown(m)
}

var xxx_messageInfo_SelfMonitor proto.InternalMessageInfo

func (m *SelfMonitor) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *SelfMonitor) GetCollector() Collector {
	if m != nil {
		return m.Collector
	}
	return Collector{}
}

func (m *SelfMonitor) GetReportSeconds() int32 {
	if m != nil {
		return m.ReportSeconds
	}
	return 0
}

// MetricsConfig 指标相关配置。
type MetricsConfig struct {
	// 是否启用
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// processor 数据处理相关配置。
	Processor MetricsProcessor `protobuf:"bytes,3,opt,name=processor,proto3" json:"processor" yaml:"processor"`
	// 数据导出（上报）相关配置。
	Exporter MetricsExporter `protobuf:"bytes,4,opt,name=exporter,proto3" json:"exporter" yaml:"exporter"`
	// 是否启用 sse
	EnableSse bool `protobuf:"varint,5,opt,name=enable_sse,json=enableSse,proto3" json:"enable_sse" yaml:"enable_sse"`
}

func (m *MetricsConfig) Reset()         { *m = MetricsConfig{} }
func (m *MetricsConfig) String() string { return proto.CompactTextString(m) }
func (*MetricsConfig) ProtoMessage()    {}
func (*MetricsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{5}
}
func (m *MetricsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsConfig.Merge(m, src)
}
func (m *MetricsConfig) XXX_Size() int {
	return m.Size()
}
func (m *MetricsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsConfig proto.InternalMessageInfo

func (m *MetricsConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *MetricsConfig) GetProcessor() MetricsProcessor {
	if m != nil {
		return m.Processor
	}
	return MetricsProcessor{}
}

func (m *MetricsConfig) GetExporter() MetricsExporter {
	if m != nil {
		return m.Exporter
	}
	return MetricsExporter{}
}

func (m *MetricsConfig) GetEnableSse() bool {
	if m != nil {
		return m.EnableSse
	}
	return false
}

// LabelIgnore 标签屏蔽。
type LabelIgnore struct {
	// MonitorName 屏蔽指标名。
	MonitorName string `protobuf:"bytes,1,opt,name=monitor_name,json=monitorName,proto3" json:"monitor_name" yaml:"monitor_name"`
	// LabelNames 屏蔽标签列表。
	LabelNames []string `protobuf:"bytes,2,rep,name=label_names,json=labelNames,proto3" json:"label_names" yaml:"label_names"`
}

func (m *LabelIgnore) Reset()         { *m = LabelIgnore{} }
func (m *LabelIgnore) String() string { return proto.CompactTextString(m) }
func (*LabelIgnore) ProtoMessage()    {}
func (*LabelIgnore) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{6}
}
func (m *LabelIgnore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelIgnore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelIgnore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelIgnore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelIgnore.Merge(m, src)
}
func (m *LabelIgnore) XXX_Size() int {
	return m.Size()
}
func (m *LabelIgnore) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelIgnore.DiscardUnknown(m)
}

var xxx_messageInfo_LabelIgnore proto.InternalMessageInfo

func (m *LabelIgnore) GetMonitorName() string {
	if m != nil {
		return m.MonitorName
	}
	return ""
}

func (m *LabelIgnore) GetLabelNames() []string {
	if m != nil {
		return m.LabelNames
	}
	return nil
}

// SecondGranularity 秒级监控。
type SecondGranularity struct {
	// MonitorName 监控项名。
	MonitorName string `protobuf:"bytes,1,opt,name=monitor_name,json=monitorName,proto3" json:"monitor_name" yaml:"monitor_name"`
	// BeginSecond 开始时间戳（秒级）。
	BeginSecond int64 `protobuf:"varint,2,opt,name=begin_second,json=beginSecond,proto3" json:"begin_second" yaml:"begin_second"`
	// EndSecond 结束时间戳（秒级）。
	EndSecond int64 `protobuf:"varint,3,opt,name=end_second,json=endSecond,proto3" json:"end_second" yaml:"end_second"`
	// WindowSeconds 秒级监控聚合窗口，单位秒，默认 1 秒。
	WindowSeconds int32 `protobuf:"varint,4,opt,name=window_seconds,json=windowSeconds,proto3" json:"window_seconds" yaml:"window_seconds"`
	// TtlSeconds 秒级数据的过期时间，单位：秒。如：3600（1 小时）
	TtlSeconds int64 `protobuf:"varint,5,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds" yaml:"ttl_seconds"`
}

func (m *SecondGranularity) Reset()         { *m = SecondGranularity{} }
func (m *SecondGranularity) String() string { return proto.CompactTextString(m) }
func (*SecondGranularity) ProtoMessage()    {}
func (*SecondGranularity) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{7}
}
func (m *SecondGranularity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondGranularity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecondGranularity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecondGranularity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondGranularity.Merge(m, src)
}
func (m *SecondGranularity) XXX_Size() int {
	return m.Size()
}
func (m *SecondGranularity) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondGranularity.DiscardUnknown(m)
}

var xxx_messageInfo_SecondGranularity proto.InternalMessageInfo

func (m *SecondGranularity) GetMonitorName() string {
	if m != nil {
		return m.MonitorName
	}
	return ""
}

func (m *SecondGranularity) GetBeginSecond() int64 {
	if m != nil {
		return m.BeginSecond
	}
	return 0
}

func (m *SecondGranularity) GetEndSecond() int64 {
	if m != nil {
		return m.EndSecond
	}
	return 0
}

func (m *SecondGranularity) GetWindowSeconds() int32 {
	if m != nil {
		return m.WindowSeconds
	}
	return 0
}

func (m *SecondGranularity) GetTtlSeconds() int64 {
	if m != nil {
		return m.TtlSeconds
	}
	return 0
}

// SampleMonitor 采样监控配置。
type SampleMonitor struct {
	// MonitorName 监控项名。
	MonitorName string `protobuf:"bytes,1,opt,name=monitor_name,json=monitorName,proto3" json:"monitor_name" yaml:"monitor_name"`
	// SamplerType 采样类型。
	SampleType MetricsSampleType `protobuf:"varint,2,opt,name=sample_type,json=sampleType,proto3,enum=model.MetricsSampleType" json:"sample_type" yaml:"sample_type"`
	// Fraction 采样率。
	Fraction float64 `protobuf:"fixed64,3,opt,name=fraction,proto3" json:"fraction" yaml:"fraction"`
}

func (m *SampleMonitor) Reset()         { *m = SampleMonitor{} }
func (m *SampleMonitor) String() string { return proto.CompactTextString(m) }
func (*SampleMonitor) ProtoMessage()    {}
func (*SampleMonitor) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{8}
}
func (m *SampleMonitor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SampleMonitor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SampleMonitor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SampleMonitor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SampleMonitor.Merge(m, src)
}
func (m *SampleMonitor) XXX_Size() int {
	return m.Size()
}
func (m *SampleMonitor) XXX_DiscardUnknown() {
	xxx_messageInfo_SampleMonitor.DiscardUnknown(m)
}

var xxx_messageInfo_SampleMonitor proto.InternalMessageInfo

func (m *SampleMonitor) GetMonitorName() string {
	if m != nil {
		return m.MonitorName
	}
	return ""
}

func (m *SampleMonitor) GetSampleType() MetricsSampleType {
	if m != nil {
		return m.SampleType
	}
	return MetricsSampleType_METRICS_SAMPLE_TYPE_INVALID
}

func (m *SampleMonitor) GetFraction() float64 {
	if m != nil {
		return m.Fraction
	}
	return 0
}

// RPCHasTwoIP 主被调监控有 "两个 ip" 配置。
// 主被调监控，"两个 ip" 举例：
// ip1、ip2、请求数 1
// ip1、ip3、请求数 2
// ip4、ip2、请求数 2
// ip4、ip3、请求数 1
// ip5、ip2、请求数 1
// ip5、ip3、请求数 2
// 主被调监控，"一个 ip" 举例：
// ip1、-、请求数 (只有主调) 3
// ip4、-、请求数 (只有主调) 3
// ip5、-、请求数 (只有主调) 3
// -、ip2、请求数 (只有被调) 4
// -、ip3、请求数 (只有被调) 5
// 因此当 ip 数较多的情况，"一个 ip" 能起到数据降维的作用，但是 "一个 ip" 无法同时查询两个 ip。
type RPCHasTwoIP struct {
	// MonitorName 监控项名。
	MonitorName string `protobuf:"bytes,1,opt,name=monitor_name,json=monitorName,proto3" json:"monitor_name" yaml:"monitor_name"`
	// BeginSecond 开始时间戳（秒级）。
	BeginSecond int64 `protobuf:"varint,2,opt,name=begin_second,json=beginSecond,proto3" json:"begin_second" yaml:"begin_second"`
	// EndSecond 结束时间戳（秒级）。
	EndSecond int64 `protobuf:"varint,3,opt,name=end_second,json=endSecond,proto3" json:"end_second" yaml:"end_second"`
}

func (m *RPCHasTwoIP) Reset()         { *m = RPCHasTwoIP{} }
func (m *RPCHasTwoIP) String() string { return proto.CompactTextString(m) }
func (*RPCHasTwoIP) ProtoMessage()    {}
func (*RPCHasTwoIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{9}
}
func (m *RPCHasTwoIP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RPCHasTwoIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RPCHasTwoIP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RPCHasTwoIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RPCHasTwoIP.Merge(m, src)
}
func (m *RPCHasTwoIP) XXX_Size() int {
	return m.Size()
}
func (m *RPCHasTwoIP) XXX_DiscardUnknown() {
	xxx_messageInfo_RPCHasTwoIP.DiscardUnknown(m)
}

var xxx_messageInfo_RPCHasTwoIP proto.InternalMessageInfo

func (m *RPCHasTwoIP) GetMonitorName() string {
	if m != nil {
		return m.MonitorName
	}
	return ""
}

func (m *RPCHasTwoIP) GetBeginSecond() int64 {
	if m != nil {
		return m.BeginSecond
	}
	return 0
}

func (m *RPCHasTwoIP) GetEndSecond() int64 {
	if m != nil {
		return m.EndSecond
	}
	return 0
}

// MetricsProcessor 监控处理器配置。
type MetricsProcessor struct {
	// Protocol 监控处理器协议，表明使用者需要的协议。
	// 系统允许实现不同协议的监控处理器并注册，这个字段用来查找工厂（见：Factories），如：omp。
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// WindowSeconds 表示数据多久聚合一次，单位秒。
	// 上报数据时的时间窗口大小，数据在此时间窗口内会被发送完毕，默认 10 秒。
	WindowSeconds int32 `protobuf:"varint,2,opt,name=window_seconds,json=windowSeconds,proto3" json:"window_seconds" yaml:"window_seconds"`
	// ClearSeconds 表示数据多久清理一次，单位秒。
	// 默认 3600 秒。
	ClearSeconds int32 `protobuf:"varint,3,opt,name=clear_seconds,json=clearSeconds,proto3" json:"clear_seconds" yaml:"clear_seconds"`
	// ExpiresSeconds 表示数据（多值点）过期时间，单位秒（如：1
	// 个主调监控维度组合，是一个多值点）。默认 3600 秒。
	ExpiresSeconds int64 `protobuf:"varint,4,opt,name=expires_seconds,json=expiresSeconds,proto3" json:"expires_seconds" yaml:"expires_seconds"`
	// PointLimit 表示数据（单值点）限制（如：1 个主调监控维度组合的 请求量 +
	// 完成量 + 耗时 是 3 个单值点）。默认 1000000。
	PointLimit int64 `protobuf:"varint,5,opt,name=point_limit,json=pointLimit,proto3" json:"point_limit" yaml:"point_limit"`
	// EnableProcessMetrics 是否开启进程监控 (process_*,go_*) 上报，默认 false。
	EnableProcessMetrics bool `protobuf:"varint,6,opt,name=enable_process_metrics,json=enableProcessMetrics,proto3" json:"enable_process_metrics" yaml:"enable_process_metrics"`
	// ProcessMetricsSeconds 进程监控上报周期，单位秒。默认 20 秒。
	ProcessMetricsSeconds int64 `protobuf:"varint,7,opt,name=process_metrics_seconds,json=processMetricsSeconds,proto3" json:"process_metrics_seconds" yaml:"process_metrics_seconds"`
	// HistogramBuckets 直方图分桶
	HistogramBuckets []HistogramBucket `protobuf:"bytes,8,rep,name=histogram_buckets,json=histogramBuckets,proto3" json:"histogram_buckets" yaml:"histogram_buckets"`
	// LabelIgnores 标签屏蔽。
	LabelIgnores []LabelIgnore `protobuf:"bytes,9,rep,name=label_ignores,json=labelIgnores,proto3" json:"label_ignores" yaml:"label_ignores"`
	// RetCodeAsException 返回码是否当成异常
	RetCodeAsException bool `protobuf:"varint,10,opt,name=ret_code_as_exception,json=retCodeAsException,proto3" json:"ret_code_as_exception" yaml:"ret_code_as_exception"`
	// SecondGranularitys 秒级监控配置。
	SecondGranularitys []SecondGranularity `protobuf:"bytes,11,rep,name=second_granularitys,json=secondGranularitys,proto3" json:"second_granularitys" yaml:"second_granularitys"`
	// SampleMonitors 监控项采样配置。
	SampleMonitors []SampleMonitor `protobuf:"bytes,12,rep,name=sample_monitors,json=sampleMonitors,proto3" json:"sample_monitors" yaml:"sample_monitors"`
	// RpcHasTwoIps 主被调监控有 "两个 ip" 配置。
	RpcHasTwoIps []RPCHasTwoIP `protobuf:"bytes,13,rep,name=rpc_has_two_ips,json=rpcHasTwoIps,proto3" json:"rpc_has_two_ips" yaml:"rpc_has_two_ips"`
}

func (m *MetricsProcessor) Reset()         { *m = MetricsProcessor{} }
func (m *MetricsProcessor) String() string { return proto.CompactTextString(m) }
func (*MetricsProcessor) ProtoMessage()    {}
func (*MetricsProcessor) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{10}
}
func (m *MetricsProcessor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsProcessor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsProcessor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsProcessor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsProcessor.Merge(m, src)
}
func (m *MetricsProcessor) XXX_Size() int {
	return m.Size()
}
func (m *MetricsProcessor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsProcessor.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsProcessor proto.InternalMessageInfo

func (m *MetricsProcessor) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *MetricsProcessor) GetWindowSeconds() int32 {
	if m != nil {
		return m.WindowSeconds
	}
	return 0
}

func (m *MetricsProcessor) GetClearSeconds() int32 {
	if m != nil {
		return m.ClearSeconds
	}
	return 0
}

func (m *MetricsProcessor) GetExpiresSeconds() int64 {
	if m != nil {
		return m.ExpiresSeconds
	}
	return 0
}

func (m *MetricsProcessor) GetPointLimit() int64 {
	if m != nil {
		return m.PointLimit
	}
	return 0
}

func (m *MetricsProcessor) GetEnableProcessMetrics() bool {
	if m != nil {
		return m.EnableProcessMetrics
	}
	return false
}

func (m *MetricsProcessor) GetProcessMetricsSeconds() int64 {
	if m != nil {
		return m.ProcessMetricsSeconds
	}
	return 0
}

func (m *MetricsProcessor) GetHistogramBuckets() []HistogramBucket {
	if m != nil {
		return m.HistogramBuckets
	}
	return nil
}

func (m *MetricsProcessor) GetLabelIgnores() []LabelIgnore {
	if m != nil {
		return m.LabelIgnores
	}
	return nil
}

func (m *MetricsProcessor) GetRetCodeAsException() bool {
	if m != nil {
		return m.RetCodeAsException
	}
	return false
}

func (m *MetricsProcessor) GetSecondGranularitys() []SecondGranularity {
	if m != nil {
		return m.SecondGranularitys
	}
	return nil
}

func (m *MetricsProcessor) GetSampleMonitors() []SampleMonitor {
	if m != nil {
		return m.SampleMonitors
	}
	return nil
}

func (m *MetricsProcessor) GetRpcHasTwoIps() []RPCHasTwoIP {
	if m != nil {
		return m.RpcHasTwoIps
	}
	return nil
}

// MetricsExporter 监控导出器配置。
type MetricsExporter struct {
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// collector 服务端
	Collector Collector `protobuf:"bytes,2,opt,name=collector,proto3" json:"collector" yaml:"collector"`
	// 上报线程数量，默认 10。
	ThreadCount int32 `protobuf:"varint,3,opt,name=thread_count,json=threadCount,proto3" json:"thread_count" yaml:"thread_count"`
	// 数据发送缓冲区大小，缓冲区满了之后，继续导出数据会阻塞住。
	// 通常此数值要设置得比较大，足够容纳几秒内的全部数据，避免阻塞。
	// 正常情况发，数据消费会比生产快，缓冲区是不会满的。
	// 数据发送缓冲区大小，默认 10000
	BufferSize int32 `protobuf:"varint,4,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size" yaml:"buffer_size"`
	// 分页上报时，每页上报的数量，默认 1000
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size" yaml:"page_size"`
	// 上报数据时的 timeout，默认 2000 ms。
	TimeoutMs int32 `protobuf:"varint,6,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms" yaml:"timeout_ms"`
	// WindowSeconds 表示数据多久聚合一次，单位秒。
	// 上报数据时的时间窗口大小，数据在此时间窗口内会被发送完毕，默认 10 秒。
	WindowSeconds int32 `protobuf:"varint,7,opt,name=window_seconds,json=windowSeconds,proto3" json:"window_seconds" yaml:"window_seconds"`
	// 最大重试次数
	MaxRetryCount int32 `protobuf:"varint,8,opt,name=max_retry_count,json=maxRetryCount,proto3" json:"max_retry_count" yaml:"max_retry_count"`
	// 是否导出到文件，此开关在调试及自动化测试中会比较有用，默认 false。
	ExportToFile bool `protobuf:"varint,9,opt,name=export_to_file,json=exportToFile,proto3" json:"export_to_file" yaml:"export_to_file"`
}

func (m *MetricsExporter) Reset()         { *m = MetricsExporter{} }
func (m *MetricsExporter) String() string { return proto.CompactTextString(m) }
func (*MetricsExporter) ProtoMessage()    {}
func (*MetricsExporter) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{11}
}
func (m *MetricsExporter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsExporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsExporter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsExporter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsExporter.Merge(m, src)
}
func (m *MetricsExporter) XXX_Size() int {
	return m.Size()
}
func (m *MetricsExporter) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsExporter.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsExporter proto.InternalMessageInfo

func (m *MetricsExporter) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *MetricsExporter) GetCollector() Collector {
	if m != nil {
		return m.Collector
	}
	return Collector{}
}

func (m *MetricsExporter) GetThreadCount() int32 {
	if m != nil {
		return m.ThreadCount
	}
	return 0
}

func (m *MetricsExporter) GetBufferSize() int32 {
	if m != nil {
		return m.BufferSize
	}
	return 0
}

func (m *MetricsExporter) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *MetricsExporter) GetTimeoutMs() int32 {
	if m != nil {
		return m.TimeoutMs
	}
	return 0
}

func (m *MetricsExporter) GetWindowSeconds() int32 {
	if m != nil {
		return m.WindowSeconds
	}
	return 0
}

func (m *MetricsExporter) GetMaxRetryCount() int32 {
	if m != nil {
		return m.MaxRetryCount
	}
	return 0
}

func (m *MetricsExporter) GetExportToFile() bool {
	if m != nil {
		return m.ExportToFile
	}
	return false
}

// PrometheusPushConfig prometheus 上报配置
type PrometheusPushConfig struct {
	// 是否启用 Prometheus 推送配置
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// Prometheus 推送的目标 URL，参考：
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url" yaml:"url"`
	// Prometheus 推送任务的名称
	Job string `protobuf:"bytes,3,opt,name=job,proto3" json:"job" yaml:"job"`
	// 推送间隔时间，单位为秒，默认 20 秒，如果需要秒级监控，可以改成 1 秒。间隔越小，成本越高。
	Interval int32 `protobuf:"varint,4,opt,name=interval,proto3" json:"interval" yaml:"interval"`
	// 是否使用基本认证
	UseBasicAuth bool `protobuf:"varint,5,opt,name=use_basic_auth,json=useBasicAuth,proto3" json:"use_basic_auth" yaml:"use_basic_auth"`
	// 认证的用户名
	Username string `protobuf:"bytes,6,opt,name=username,proto3" json:"username" yaml:"username"`
	// 认证的密码
	Password string `protobuf:"bytes,7,opt,name=password,proto3" json:"password" yaml:"password"`
	// 分组信息，键值对形式
	Grouping map[string]string `protobuf:"bytes,8,rep,name=grouping,proto3" json:"grouping" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" yaml:"grouping"`
	// HTTP 头信息，键值对形式
	HttpHeaders map[string]string `protobuf:"bytes,9,rep,name=http_headers,json=httpHeaders,proto3" json:"http_headers" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" yaml:"http_headers"`
}

func (m *PrometheusPushConfig) Reset()         { *m = PrometheusPushConfig{} }
func (m *PrometheusPushConfig) String() string { return proto.CompactTextString(m) }
func (*PrometheusPushConfig) ProtoMessage()    {}
func (*PrometheusPushConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{12}
}
func (m *PrometheusPushConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrometheusPushConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrometheusPushConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrometheusPushConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrometheusPushConfig.Merge(m, src)
}
func (m *PrometheusPushConfig) XXX_Size() int {
	return m.Size()
}
func (m *PrometheusPushConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PrometheusPushConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PrometheusPushConfig proto.InternalMessageInfo

func (m *PrometheusPushConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *PrometheusPushConfig) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PrometheusPushConfig) GetJob() string {
	if m != nil {
		return m.Job
	}
	return ""
}

func (m *PrometheusPushConfig) GetInterval() int32 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *PrometheusPushConfig) GetUseBasicAuth() bool {
	if m != nil {
		return m.UseBasicAuth
	}
	return false
}

func (m *PrometheusPushConfig) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *PrometheusPushConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *PrometheusPushConfig) GetGrouping() map[string]string {
	if m != nil {
		return m.Grouping
	}
	return nil
}

func (m *PrometheusPushConfig) GetHttpHeaders() map[string]string {
	if m != nil {
		return m.HttpHeaders
	}
	return nil
}

// OpenTelemetryPushConfig OpenTelemetry 上报配置
type OpenTelemetryPushConfig struct {
	// 是否启用 OpenTelemetry 推送配置
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// OpenTelemetry 推送的目标 URL，参考：和：Traces、Logs 使用相同地址。
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url" yaml:"url"`
}

func (m *OpenTelemetryPushConfig) Reset()         { *m = OpenTelemetryPushConfig{} }
func (m *OpenTelemetryPushConfig) String() string { return proto.CompactTextString(m) }
func (*OpenTelemetryPushConfig) ProtoMessage()    {}
func (*OpenTelemetryPushConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{13}
}
func (m *OpenTelemetryPushConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenTelemetryPushConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenTelemetryPushConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenTelemetryPushConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenTelemetryPushConfig.Merge(m, src)
}
func (m *OpenTelemetryPushConfig) XXX_Size() int {
	return m.Size()
}
func (m *OpenTelemetryPushConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenTelemetryPushConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OpenTelemetryPushConfig proto.InternalMessageInfo

func (m *OpenTelemetryPushConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *OpenTelemetryPushConfig) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// HistogramBucket 直方图分桶
type HistogramBucket struct {
	// name：指标名
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	// buckets：递增桶，如：{0, 0.1, 0.2, 0.5}
	Buckets []float64 `protobuf:"fixed64,2,rep,packed,name=buckets,proto3" json:"buckets" yaml:"buckets"`
}

func (m *HistogramBucket) Reset()         { *m = HistogramBucket{} }
func (m *HistogramBucket) String() string { return proto.CompactTextString(m) }
func (*HistogramBucket) ProtoMessage()    {}
func (*HistogramBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{14}
}
func (m *HistogramBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistogramBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistogramBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistogramBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistogramBucket.Merge(m, src)
}
func (m *HistogramBucket) XXX_Size() int {
	return m.Size()
}
func (m *HistogramBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_HistogramBucket.DiscardUnknown(m)
}

var xxx_messageInfo_HistogramBucket proto.InternalMessageInfo

func (m *HistogramBucket) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HistogramBucket) GetBuckets() []float64 {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// TracesConfig 追踪相关配置。
type TracesConfig struct {
	// 是否启用
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// processor 数据处理相关配置。
	Processor TracesProcessor `protobuf:"bytes,3,opt,name=processor,proto3" json:"processor" yaml:"processor"`
	// 数据导出（上报）相关配置。
	Exporter TracesExporter `protobuf:"bytes,4,opt,name=exporter,proto3" json:"exporter" yaml:"exporter"`
	// 是否启用 sse
	EnableSse bool `protobuf:"varint,5,opt,name=enable_sse,json=enableSse,proto3" json:"enable_sse" yaml:"enable_sse"`
}

func (m *TracesConfig) Reset()         { *m = TracesConfig{} }
func (m *TracesConfig) String() string { return proto.CompactTextString(m) }
func (*TracesConfig) ProtoMessage()    {}
func (*TracesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{15}
}
func (m *TracesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracesConfig.Merge(m, src)
}
func (m *TracesConfig) XXX_Size() int {
	return m.Size()
}
func (m *TracesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TracesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TracesConfig proto.InternalMessageInfo

func (m *TracesConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *TracesConfig) GetProcessor() TracesProcessor {
	if m != nil {
		return m.Processor
	}
	return TracesProcessor{}
}

func (m *TracesConfig) GetExporter() TracesExporter {
	if m != nil {
		return m.Exporter
	}
	return TracesExporter{}
}

func (m *TracesConfig) GetEnableSse() bool {
	if m != nil {
		return m.EnableSse
	}
	return false
}

type TracesProcessor struct {
	// 如：omp。
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// 采样器配置
	Sampler SamplerConfig `protobuf:"bytes,3,opt,name=sampler,proto3" json:"sampler" yaml:"sampler"`
	// 若为 true，则关闭 trace 中对 req 和 rsp 的上报，可以提高上报性能。默认
	// true。
	DisableTraceBody bool `protobuf:"varint,4,opt,name=disable_trace_body,json=disableTraceBody,proto3" json:"disable_trace_body" yaml:"disable_trace_body"`
	// 若为 true，则关闭 流式调用中 trace 中对 req 和 rsp 的上报，可以提高上报性能。默认
	// true。
	DisableStreamTraceBody bool `protobuf:"varint,11,opt,name=disable_stream_trace_body,json=disableStreamTraceBody,proto3" json:"disable_stream_trace_body" yaml:"disable_stream_trace_body"`
	// EnableDeferredSample 是否开启延迟采样，默认 false。
	EnableDeferredSample bool `protobuf:"varint,5,opt,name=enable_deferred_sample,json=enableDeferredSample,proto3" json:"enable_deferred_sample" yaml:"enable_deferred_sample"`
	// DeferredSampleError 延迟采样 - 出错采样，默认 false。
	DeferredSampleError bool `protobuf:"varint,6,opt,name=deferred_sample_error,json=deferredSampleError,proto3" json:"deferred_sample_error" yaml:"deferred_sample_error"`
	// DeferredSampleSlowDuration 延迟采样 - 慢操作采样，慢操作阈值，单位 ms，默认
	// 0。
	DeferredSampleSlowDurationMs int64 `protobuf:"varint,7,opt,name=deferred_sample_slow_duration_ms,json=deferredSampleSlowDurationMs,proto3" json:"deferred_sample_slow_duration_ms" yaml:"deferred_sample_slow_duration_ms"`
	// DisableParentSampling 忽略上游的采样结果，默认 false。
	DisableParentSampling bool `protobuf:"varint,8,opt,name=disable_parent_sampling,json=disableParentSampling,proto3" json:"disable_parent_sampling" yaml:"disable_parent_sampling"`
	// Workflow 采样配置，用户不可见，仅由服务端下发
	WorkflowSampler WorkflowSamplerConfig `protobuf:"bytes,9,opt,name=workflow_sampler,json=workflowSampler,proto3" json:"workflow_sampler" yaml:"workflow_sampler"`
	// 开启 trace 与 profile 的关联，需要同时配置 profiles_config -> enable: true
	// 才可生效。
	EnableProfile bool `protobuf:"varint,10,opt,name=enable_profile,json=enableProfile,proto3" json:"enable_profile" yaml:"enable_profile"`
}

func (m *TracesProcessor) Reset()         { *m = TracesProcessor{} }
func (m *TracesProcessor) String() string { return proto.CompactTextString(m) }
func (*TracesProcessor) ProtoMessage()    {}
func (*TracesProcessor) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{16}
}
func (m *TracesProcessor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracesProcessor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracesProcessor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracesProcessor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracesProcessor.Merge(m, src)
}
func (m *TracesProcessor) XXX_Size() int {
	return m.Size()
}
func (m *TracesProcessor) XXX_DiscardUnknown() {
	xxx_messageInfo_TracesProcessor.DiscardUnknown(m)
}

var xxx_messageInfo_TracesProcessor proto.InternalMessageInfo

func (m *TracesProcessor) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *TracesProcessor) GetSampler() SamplerConfig {
	if m != nil {
		return m.Sampler
	}
	return SamplerConfig{}
}

func (m *TracesProcessor) GetDisableTraceBody() bool {
	if m != nil {
		return m.DisableTraceBody
	}
	return false
}

func (m *TracesProcessor) GetDisableStreamTraceBody() bool {
	if m != nil {
		return m.DisableStreamTraceBody
	}
	return false
}

func (m *TracesProcessor) GetEnableDeferredSample() bool {
	if m != nil {
		return m.EnableDeferredSample
	}
	return false
}

func (m *TracesProcessor) GetDeferredSampleError() bool {
	if m != nil {
		return m.DeferredSampleError
	}
	return false
}

func (m *TracesProcessor) GetDeferredSampleSlowDurationMs() int64 {
	if m != nil {
		return m.DeferredSampleSlowDurationMs
	}
	return 0
}

func (m *TracesProcessor) GetDisableParentSampling() bool {
	if m != nil {
		return m.DisableParentSampling
	}
	return false
}

func (m *TracesProcessor) GetWorkflowSampler() WorkflowSamplerConfig {
	if m != nil {
		return m.WorkflowSampler
	}
	return WorkflowSamplerConfig{}
}

func (m *TracesProcessor) GetEnableProfile() bool {
	if m != nil {
		return m.EnableProfile
	}
	return false
}

type TracesExporter struct {
	// protocol 如：otlp。
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// collector 服务端信息
	Collector Collector `protobuf:"bytes,2,opt,name=collector,proto3" json:"collector" yaml:"collector"`
	// 数据发送缓冲区大小，缓冲区满了之后，继续导出数据会阻塞住。
	// 通常此数值要设置得比较大，足够容纳几秒内的全部数据，避免阻塞。
	// 正常情况发，数据消费会比生产快，缓冲区是不会满的。
	// 数据发送缓冲区大小，默认 10000
	BufferSize int32 `protobuf:"varint,4,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size" yaml:"buffer_size"`
	// 分页上报时，每页上报的数量，默认 1000
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size" yaml:"page_size"`
	// WindowSeconds 表示数据多久聚合一次，单位秒。
	// 上报数据时的时间窗口大小，数据在此时间窗口内会被发送完毕，默认 10 秒。
	WindowSeconds int32 `protobuf:"varint,7,opt,name=window_seconds,json=windowSeconds,proto3" json:"window_seconds" yaml:"window_seconds"`
	// 每个数据包大小，超过此大小时一定发送
	PacketSize int32 `protobuf:"varint,8,opt,name=packet_size,json=packetSize,proto3" json:"packet_size" yaml:"packet_size"`
	// 是否导出到文件，此开关在调试及自动化测试中会比较有用，默认 false。
	ExportToFile bool `protobuf:"varint,9,opt,name=export_to_file,json=exportToFile,proto3" json:"export_to_file" yaml:"export_to_file"`
}

func (m *TracesExporter) Reset()         { *m = TracesExporter{} }
func (m *TracesExporter) String() string { return proto.CompactTextString(m) }
func (*TracesExporter) ProtoMessage()    {}
func (*TracesExporter) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{17}
}
func (m *TracesExporter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TracesExporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TracesExporter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TracesExporter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TracesExporter.Merge(m, src)
}
func (m *TracesExporter) XXX_Size() int {
	return m.Size()
}
func (m *TracesExporter) XXX_DiscardUnknown() {
	xxx_messageInfo_TracesExporter.DiscardUnknown(m)
}

var xxx_messageInfo_TracesExporter proto.InternalMessageInfo

func (m *TracesExporter) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *TracesExporter) GetCollector() Collector {
	if m != nil {
		return m.Collector
	}
	return Collector{}
}

func (m *TracesExporter) GetBufferSize() int32 {
	if m != nil {
		return m.BufferSize
	}
	return 0
}

func (m *TracesExporter) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *TracesExporter) GetWindowSeconds() int32 {
	if m != nil {
		return m.WindowSeconds
	}
	return 0
}

func (m *TracesExporter) GetPacketSize() int32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *TracesExporter) GetExportToFile() bool {
	if m != nil {
		return m.ExportToFile
	}
	return false
}

// LogsConfig 日志相关配置。
type LogsConfig struct {
	// 是否启用
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// processor 数据处理相关配置。
	Processor LogsProcessor `protobuf:"bytes,3,opt,name=processor,proto3" json:"processor" yaml:"processor"`
	// 数据导出（上报）相关配置。
	Exporter LogsExporter `protobuf:"bytes,4,opt,name=exporter,proto3" json:"exporter" yaml:"exporter"`
}

func (m *LogsConfig) Reset()         { *m = LogsConfig{} }
func (m *LogsConfig) String() string { return proto.CompactTextString(m) }
func (*LogsConfig) ProtoMessage()    {}
func (*LogsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{18}
}
func (m *LogsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsConfig.Merge(m, src)
}
func (m *LogsConfig) XXX_Size() int {
	return m.Size()
}
func (m *LogsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LogsConfig proto.InternalMessageInfo

func (m *LogsConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *LogsConfig) GetProcessor() LogsProcessor {
	if m != nil {
		return m.Processor
	}
	return LogsProcessor{}
}

func (m *LogsConfig) GetExporter() LogsExporter {
	if m != nil {
		return m.Exporter
	}
	return LogsExporter{}
}

// LogsProcessor 日志处理器配置。
type LogsProcessor struct {
	// 如：omp。
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// OnlyTraceLog 只输出 trace 的 log。默认 false，即输出全部 log。
	OnlyTraceLog bool `protobuf:"varint,2,opt,name=only_trace_log,json=onlyTraceLog,proto3" json:"only_trace_log" yaml:"only_trace_log"`
	// 日志格式，0,1,2,3，默认 0
	TraceLogMode int32 `protobuf:"varint,4,opt,name=trace_log_mode,json=traceLogMode,proto3" json:"trace_log_mode" yaml:"trace_log_mode"`
	// debug, info, error，默认 error
	Level string `protobuf:"bytes,5,opt,name=level,proto3" json:"level" yaml:"level"`
	// 是否捕获 panic，默认 true
	EnableRecovery bool `protobuf:"varint,6,opt,name=enable_recovery,json=enableRecovery,proto3" json:"enable_recovery" yaml:"enable_recovery"`
	// 是否只要命中 trace 的日志不分级别都上报。默认 false
	MustLogTraced bool `protobuf:"varint,7,opt,name=must_log_traced,json=mustLogTraced,proto3" json:"must_log_traced" yaml:"must_log_traced"`
	// dyeing|sample 命中染色还是命中采样
	LogTracedType string `protobuf:"bytes,8,opt,name=log_traced_type,json=logTracedType,proto3" json:"log_traced_type" yaml:"log_traced_type"`
}

func (m *LogsProcessor) Reset()         { *m = LogsProcessor{} }
func (m *LogsProcessor) String() string { return proto.CompactTextString(m) }
func (*LogsProcessor) ProtoMessage()    {}
func (*LogsProcessor) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{19}
}
func (m *LogsProcessor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsProcessor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsProcessor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsProcessor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsProcessor.Merge(m, src)
}
func (m *LogsProcessor) XXX_Size() int {
	return m.Size()
}
func (m *LogsProcessor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsProcessor.DiscardUnknown(m)
}

var xxx_messageInfo_LogsProcessor proto.InternalMessageInfo

func (m *LogsProcessor) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *LogsProcessor) GetOnlyTraceLog() bool {
	if m != nil {
		return m.OnlyTraceLog
	}
	return false
}

func (m *LogsProcessor) GetTraceLogMode() int32 {
	if m != nil {
		return m.TraceLogMode
	}
	return 0
}

func (m *LogsProcessor) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *LogsProcessor) GetEnableRecovery() bool {
	if m != nil {
		return m.EnableRecovery
	}
	return false
}

func (m *LogsProcessor) GetMustLogTraced() bool {
	if m != nil {
		return m.MustLogTraced
	}
	return false
}

func (m *LogsProcessor) GetLogTracedType() string {
	if m != nil {
		return m.LogTracedType
	}
	return ""
}

// LogsExporter 日志导出器配置。
type LogsExporter struct {
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// collector 服务端信息
	Collector Collector `protobuf:"bytes,2,opt,name=collector,proto3" json:"collector" yaml:"collector"`
	// 数据发送缓冲区大小，缓冲区满了之后，继续导出数据会阻塞住。
	// 通常此数值要设置得比较大，足够容纳几秒内的全部数据，避免阻塞。
	// 正常情况发，数据消费会比生产快，缓冲区是不会满的。
	// 数据发送缓冲区大小，默认 10000
	BufferSize int32 `protobuf:"varint,4,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size" yaml:"buffer_size"`
	// 分页上报时，每页上报的数量，默认 1000
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size" yaml:"page_size"`
	// WindowSeconds 表示数据多久聚合一次，单位秒。
	// 上报数据时的时间窗口大小，数据在此时间窗口内会被发送完毕，默认 10 秒。
	WindowSeconds int32 `protobuf:"varint,7,opt,name=window_seconds,json=windowSeconds,proto3" json:"window_seconds" yaml:"window_seconds"`
	// 每个数据包大小，超过此大小时一定发送
	PacketSize int32 `protobuf:"varint,8,opt,name=packet_size,json=packetSize,proto3" json:"packet_size" yaml:"packet_size"`
	// 是否导出到文件，此开关在调试及自动化测试中会比较有用，默认 false。
	ExportToFile bool `protobuf:"varint,9,opt,name=export_to_file,json=exportToFile,proto3" json:"export_to_file" yaml:"export_to_file"`
}

func (m *LogsExporter) Reset()         { *m = LogsExporter{} }
func (m *LogsExporter) String() string { return proto.CompactTextString(m) }
func (*LogsExporter) ProtoMessage()    {}
func (*LogsExporter) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{20}
}
func (m *LogsExporter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsExporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogsExporter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogsExporter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsExporter.Merge(m, src)
}
func (m *LogsExporter) XXX_Size() int {
	return m.Size()
}
func (m *LogsExporter) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsExporter.DiscardUnknown(m)
}

var xxx_messageInfo_LogsExporter proto.InternalMessageInfo

func (m *LogsExporter) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *LogsExporter) GetCollector() Collector {
	if m != nil {
		return m.Collector
	}
	return Collector{}
}

func (m *LogsExporter) GetBufferSize() int32 {
	if m != nil {
		return m.BufferSize
	}
	return 0
}

func (m *LogsExporter) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *LogsExporter) GetWindowSeconds() int32 {
	if m != nil {
		return m.WindowSeconds
	}
	return 0
}

func (m *LogsExporter) GetPacketSize() int32 {
	if m != nil {
		return m.PacketSize
	}
	return 0
}

func (m *LogsExporter) GetExportToFile() bool {
	if m != nil {
		return m.ExportToFile
	}
	return false
}

type ProfilesConfig struct {
	// 是否启用
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// processor 数据额处理相关配置
	Processor ProfilesProcessor `protobuf:"bytes,3,opt,name=processor,proto3" json:"processor" yaml:"processor"`
	// 数据导出（上报）相关配置
	Exporter ProfilesExporter `protobuf:"bytes,4,opt,name=exporter,proto3" json:"exporter" yaml:"exporter"`
}

func (m *ProfilesConfig) Reset()         { *m = ProfilesConfig{} }
func (m *ProfilesConfig) String() string { return proto.CompactTextString(m) }
func (*ProfilesConfig) ProtoMessage()    {}
func (*ProfilesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{21}
}
func (m *ProfilesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfilesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfilesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfilesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfilesConfig.Merge(m, src)
}
func (m *ProfilesConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProfilesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfilesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProfilesConfig proto.InternalMessageInfo

func (m *ProfilesConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *ProfilesConfig) GetProcessor() ProfilesProcessor {
	if m != nil {
		return m.Processor
	}
	return ProfilesProcessor{}
}

func (m *ProfilesConfig) GetExporter() ProfilesExporter {
	if m != nil {
		return m.Exporter
	}
	return ProfilesExporter{}
}

type ProfilesProcessor struct {
	// Protocol 监控处理器协议，表明使用者需要的协议。
	// 系统允许实现不同协议的监控处理器并注册，这个字段用来查找工厂（见：Factories），如：omp。
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// 采集的性能数据类型，支持 CPU、heap、mutex、block、goroutine，默认开启 CPU
	// 和 heap。
	ProfileTypes []string `protobuf:"bytes,3,rep,name=profile_types,json=profileTypes,proto3" json:"profile_types" yaml:"profile_types"`
	// 采集周期，单位 s，默认 60s，即采集 60s 上传一次。
	PeriodSeconds int64 `protobuf:"varint,4,opt,name=period_seconds,json=periodSeconds,proto3" json:"period_seconds" yaml:"period_seconds"`
	// 每一个采集周期内，CPU profile 采集的时长，默认与 period_seconds 等长，即
	// 60s。
	CpuDurationSeconds int64 `protobuf:"varint,5,opt,name=cpu_duration_seconds,json=cpuDurationSeconds,proto3" json:"cpu_duration_seconds" yaml:"cpu_duration_seconds"`
	// CPU profile 采样频率（Hz），即每秒采集多少 CPU Profile
	// samples，一般不需要设置。默认为 100 Hz（最佳实践），即 on-cpu 时间 > 10ms
	// 的调用可以被采到，建议不要超过 500 Hz，参考
	// https://github.com/golang/go/blob/go1.18/src/runtime/pprof/pprof.go#L763-L771。
	// 设置 rate 为非 100 的值，会打印，
	// warning "runtime: cannot set CPU profile rate until previous profile has
	// finished"，可忽略该 warning，详细原因请参考
	// 0：关闭 CPU profiling
	CpuProfileRate int32 `protobuf:"varint,6,opt,name=cpu_profile_rate,json=cpuProfileRate,proto3" json:"cpu_profile_rate" yaml:"cpu_profile_rate"`
	// mutex 锁竞争采样频率，默认 10。
	// rate = 1：采样所有的 mutex event
	// rate > 1：随机采样 1/rate 的 mutex event
	MutexProfileFraction int32 `protobuf:"varint,7,opt,name=mutex_profile_fraction,json=mutexProfileFraction,proto3" json:"mutex_profile_fraction" yaml:"mutex_profile_fraction"`
	// 阻塞事件采样频率，默认 100000000，即 100ms。
	// rate <= 0：关闭 block profiling
	// rate = 1：采样所有的 block event
	// rate > 1：阻塞时间 t > rate（nanoseconds）的 event 一定会被统计，t < rate
	// 则有 t/rate 的概率被采样。
	BlockProfileRate int32 `protobuf:"varint,8,opt,name=block_profile_rate,json=blockProfileRate,proto3" json:"block_profile_rate" yaml:"block_profile_rate"`
	// 是否开启 delta profile 增量收集 profile 数据，目前 heap、block、mutex
	// 支持增量收集，默认是 true。
	EnableDeltaProfiles bool `protobuf:"varint,9,opt,name=enable_delta_profiles,json=enableDeltaProfiles,proto3" json:"enable_delta_profiles" yaml:"enable_delta_profiles"`
	// 是否开启 profile 关联 trace，默认是 false。
	EnableLinkTrace bool `protobuf:"varint,10,opt,name=enable_link_trace,json=enableLinkTrace,proto3" json:"enable_link_trace" yaml:"enable_link_trace"`
}

func (m *ProfilesProcessor) Reset()         { *m = ProfilesProcessor{} }
func (m *ProfilesProcessor) String() string { return proto.CompactTextString(m) }
func (*ProfilesProcessor) ProtoMessage()    {}
func (*ProfilesProcessor) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{22}
}
func (m *ProfilesProcessor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfilesProcessor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfilesProcessor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfilesProcessor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfilesProcessor.Merge(m, src)
}
func (m *ProfilesProcessor) XXX_Size() int {
	return m.Size()
}
func (m *ProfilesProcessor) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfilesProcessor.DiscardUnknown(m)
}

var xxx_messageInfo_ProfilesProcessor proto.InternalMessageInfo

func (m *ProfilesProcessor) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ProfilesProcessor) GetProfileTypes() []string {
	if m != nil {
		return m.ProfileTypes
	}
	return nil
}

func (m *ProfilesProcessor) GetPeriodSeconds() int64 {
	if m != nil {
		return m.PeriodSeconds
	}
	return 0
}

func (m *ProfilesProcessor) GetCpuDurationSeconds() int64 {
	if m != nil {
		return m.CpuDurationSeconds
	}
	return 0
}

func (m *ProfilesProcessor) GetCpuProfileRate() int32 {
	if m != nil {
		return m.CpuProfileRate
	}
	return 0
}

func (m *ProfilesProcessor) GetMutexProfileFraction() int32 {
	if m != nil {
		return m.MutexProfileFraction
	}
	return 0
}

func (m *ProfilesProcessor) GetBlockProfileRate() int32 {
	if m != nil {
		return m.BlockProfileRate
	}
	return 0
}

func (m *ProfilesProcessor) GetEnableDeltaProfiles() bool {
	if m != nil {
		return m.EnableDeltaProfiles
	}
	return false
}

func (m *ProfilesProcessor) GetEnableLinkTrace() bool {
	if m != nil {
		return m.EnableLinkTrace
	}
	return false
}

type ProfilesExporter struct {
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol" yaml:"protocol"`
	// collector 服务端信息
	Collector Collector `protobuf:"bytes,2,opt,name=collector,proto3" json:"collector" yaml:"collector"`
	// 数据发送缓冲区大小，即 PofilesBatch 的个数，默认 5。
	BufferSize int32 `protobuf:"varint,4,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size" yaml:"buffer_size"`
	// 上报数据时的 timeout，默认 2000 ms。
	TimeoutMs int32 `protobuf:"varint,6,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms" yaml:"timeout_ms"`
	// 最大重试次数
	MaxRetryCount int32 `protobuf:"varint,8,opt,name=max_retry_count,json=maxRetryCount,proto3" json:"max_retry_count" yaml:"max_retry_count"`
	// 是否导出到文件，此开关在调试及自动化测试中会比较有用，默认 false。
	ExportToFile bool `protobuf:"varint,9,opt,name=export_to_file,json=exportToFile,proto3" json:"export_to_file" yaml:"export_to_file"`
}

func (m *ProfilesExporter) Reset()         { *m = ProfilesExporter{} }
func (m *ProfilesExporter) String() string { return proto.CompactTextString(m) }
func (*ProfilesExporter) ProtoMessage()    {}
func (*ProfilesExporter) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{23}
}
func (m *ProfilesExporter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfilesExporter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfilesExporter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfilesExporter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfilesExporter.Merge(m, src)
}
func (m *ProfilesExporter) XXX_Size() int {
	return m.Size()
}
func (m *ProfilesExporter) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfilesExporter.DiscardUnknown(m)
}

var xxx_messageInfo_ProfilesExporter proto.InternalMessageInfo

func (m *ProfilesExporter) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ProfilesExporter) GetCollector() Collector {
	if m != nil {
		return m.Collector
	}
	return Collector{}
}

func (m *ProfilesExporter) GetBufferSize() int32 {
	if m != nil {
		return m.BufferSize
	}
	return 0
}

func (m *ProfilesExporter) GetTimeoutMs() int32 {
	if m != nil {
		return m.TimeoutMs
	}
	return 0
}

func (m *ProfilesExporter) GetMaxRetryCount() int32 {
	if m != nil {
		return m.MaxRetryCount
	}
	return 0
}

func (m *ProfilesExporter) GetExportToFile() bool {
	if m != nil {
		return m.ExportToFile
	}
	return false
}

// SamplerConfig sampler config
type SamplerConfig struct {
	// Enable 是否采样，默认开启
	Enable bool `protobuf:"varint,1,opt,name=enable,proto3" json:"enable" yaml:"enable"`
	// Fraction 一般采样率，默认 0
	Fraction float64 `protobuf:"fixed64,2,opt,name=fraction,proto3" json:"fraction" yaml:"fraction"`
	// ErrorFraction 出错时采样率，默认 0
	ErrorFraction float64 `protobuf:"fixed64,3,opt,name=error_fraction,json=errorFraction,proto3" json:"error_fraction" yaml:"error_fraction"`
	// Dyeing 染色元数据。
	Dyeing []Dyeing `protobuf:"bytes,4,rep,name=dyeing,proto3" json:"dyeing" yaml:"dyeing"`
	// EnableDyeing，是否开启染色，默认 true。
	EnableDyeing bool `protobuf:"varint,5,opt,name=enable_dyeing,json=enableDyeing,proto3" json:"enable_dyeing" yaml:"enable_dyeing"`
	// 每分钟最小采样数，group by (caller_method,
	// callee_method)。此字段已经废弃，等 v0.5.0 删除。
	// int32 min_sample_count = 6;
	// WindowInterval 统计时间窗口大小（秒）, 默认 60 秒。此字段已经废弃，等
	// v0.5.0 删除。
	// int32 window_interval = 7;
	// WindowMaxKeyCount
	// 最大组合数，限制内存使用量，避免内存爆炸。此字段已经废弃，等 v0.5.0 删除。
	// int32 window_max_key_count = 8;
	// 是否开启最小采样，默认 false。
	EnableMinSample bool `protobuf:"varint,9,opt,name=enable_min_sample,json=enableMinSample,proto3" json:"enable_min_sample" yaml:"enable_min_sample"`
	// 是否开启布隆过滤器染色，默认 false，由 ocp 服务控制。
	EnableBloomDyeing bool `protobuf:"varint,10,opt,name=enable_bloom_dyeing,json=enableBloomDyeing,proto3" json:"enable_bloom_dyeing" yaml:"enable_bloom_dyeing"`
	// 布隆过滤器染色元数据。
	BloomDyeing []BloomDyeing `protobuf:"bytes,11,rep,name=bloom_dyeing,json=bloomDyeing,proto3" json:"bloom_dyeing" yaml:"bloom_dyeing"`
	// 过载保护配置
	RateLimit []*TokenBucketConfig `protobuf:"bytes,12,rep,name=rate_limit,json=rateLimit,proto3" json:"rate_limit" yaml:"rate_limit"`
	// 被调采样配置。
	Server RpcSamplingConfig `protobuf:"bytes,13,opt,name=server,proto3" json:"server" yaml:"server"`
	// 主调采样配置。
	Client RpcSamplingConfig `protobuf:"bytes,14,opt,name=client,proto3" json:"client" yaml:"client"`
}

func (m *SamplerConfig) Reset()         { *m = SamplerConfig{} }
func (m *SamplerConfig) String() string { return proto.CompactTextString(m) }
func (*SamplerConfig) ProtoMessage()    {}
func (*SamplerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{24}
}
func (m *SamplerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SamplerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SamplerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SamplerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SamplerConfig.Merge(m, src)
}
func (m *SamplerConfig) XXX_Size() int {
	return m.Size()
}
func (m *SamplerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SamplerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SamplerConfig proto.InternalMessageInfo

func (m *SamplerConfig) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *SamplerConfig) GetFraction() float64 {
	if m != nil {
		return m.Fraction
	}
	return 0
}

func (m *SamplerConfig) GetErrorFraction() float64 {
	if m != nil {
		return m.ErrorFraction
	}
	return 0
}

func (m *SamplerConfig) GetDyeing() []Dyeing {
	if m != nil {
		return m.Dyeing
	}
	return nil
}

func (m *SamplerConfig) GetEnableDyeing() bool {
	if m != nil {
		return m.EnableDyeing
	}
	return false
}

func (m *SamplerConfig) GetEnableMinSample() bool {
	if m != nil {
		return m.EnableMinSample
	}
	return false
}

func (m *SamplerConfig) GetEnableBloomDyeing() bool {
	if m != nil {
		return m.EnableBloomDyeing
	}
	return false
}

func (m *SamplerConfig) GetBloomDyeing() []BloomDyeing {
	if m != nil {
		return m.BloomDyeing
	}
	return nil
}

func (m *SamplerConfig) GetRateLimit() []*TokenBucketConfig {
	if m != nil {
		return m.RateLimit
	}
	return nil
}

func (m *SamplerConfig) GetServer() RpcSamplingConfig {
	if m != nil {
		return m.Server
	}
	return RpcSamplingConfig{}
}

func (m *SamplerConfig) GetClient() RpcSamplingConfig {
	if m != nil {
		return m.Client
	}
	return RpcSamplingConfig{}
}

// WorkflowSamplerConfig 默认采样配置
type WorkflowSamplerConfig struct {
	// 每分钟基准采样数
	SampleCountPerMinute int32 `protobuf:"varint,1,opt,name=sample_count_per_minute,json=sampleCountPerMinute,proto3" json:"sample_count_per_minute" yaml:"sample_count_per_minute"`
	// 每分钟熔断最大限制
	MaxCountPerMinute int32 `protobuf:"varint,2,opt,name=max_count_per_minute,json=maxCountPerMinute,proto3" json:"max_count_per_minute" yaml:"max_count_per_minute"`
	// path 算法全局 cache 大小
	PathMaxCount int32 `protobuf:"varint,3,opt,name=path_max_count,json=pathMaxCount,proto3" json:"path_max_count" yaml:"path_max_count"`
	// path 算法 cache 生存周期，单位秒
	LifetimeSec int32 `protobuf:"varint,4,opt,name=lifetime_sec,json=lifetimeSec,proto3" json:"lifetime_sec" yaml:"lifetime_sec"`
}

func (m *WorkflowSamplerConfig) Reset()         { *m = WorkflowSamplerConfig{} }
func (m *WorkflowSamplerConfig) String() string { return proto.CompactTextString(m) }
func (*WorkflowSamplerConfig) ProtoMessage()    {}
func (*WorkflowSamplerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{25}
}
func (m *WorkflowSamplerConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowSamplerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowSamplerConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowSamplerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowSamplerConfig.Merge(m, src)
}
func (m *WorkflowSamplerConfig) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowSamplerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowSamplerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowSamplerConfig proto.InternalMessageInfo

func (m *WorkflowSamplerConfig) GetSampleCountPerMinute() int32 {
	if m != nil {
		return m.SampleCountPerMinute
	}
	return 0
}

func (m *WorkflowSamplerConfig) GetMaxCountPerMinute() int32 {
	if m != nil {
		return m.MaxCountPerMinute
	}
	return 0
}

func (m *WorkflowSamplerConfig) GetPathMaxCount() int32 {
	if m != nil {
		return m.PathMaxCount
	}
	return 0
}

func (m *WorkflowSamplerConfig) GetLifetimeSec() int32 {
	if m != nil {
		return m.LifetimeSec
	}
	return 0
}

// TokenBucketConfig 限速配置
type TokenBucketConfig struct {
	// strategy: root 采样策略名 (default|dyeing|random|min_count)
	Strategy string `protobuf:"bytes,1,opt,name=strategy,proto3" json:"strategy" yaml:"strategy"`
	// 单位时间（默认秒）平均限制数
	Rate uint64 `protobuf:"varint,2,opt,name=rate,proto3" json:"rate" yaml:"rate"`
	// 单位时间（默认秒）突发限制数
	Burst uint64 `protobuf:"varint,3,opt,name=burst,proto3" json:"burst" yaml:"burst"`
}

func (m *TokenBucketConfig) Reset()         { *m = TokenBucketConfig{} }
func (m *TokenBucketConfig) String() string { return proto.CompactTextString(m) }
func (*TokenBucketConfig) ProtoMessage()    {}
func (*TokenBucketConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{26}
}
func (m *TokenBucketConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenBucketConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenBucketConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenBucketConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenBucketConfig.Merge(m, src)
}
func (m *TokenBucketConfig) XXX_Size() int {
	return m.Size()
}
func (m *TokenBucketConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenBucketConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TokenBucketConfig proto.InternalMessageInfo

func (m *TokenBucketConfig) GetStrategy() string {
	if m != nil {
		return m.Strategy
	}
	return ""
}

func (m *TokenBucketConfig) GetRate() uint64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

func (m *TokenBucketConfig) GetBurst() uint64 {
	if m != nil {
		return m.Burst
	}
	return 0
}

type Dyeing struct {
	// 染色的 key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key" yaml:"key"`
	// 染色的 values
	Values []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values" yaml:"values"`
}

func (m *Dyeing) Reset()         { *m = Dyeing{} }
func (m *Dyeing) String() string { return proto.CompactTextString(m) }
func (*Dyeing) ProtoMessage()    {}
func (*Dyeing) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{27}
}
func (m *Dyeing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dyeing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dyeing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dyeing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dyeing.Merge(m, src)
}
func (m *Dyeing) XXX_Size() int {
	return m.Size()
}
func (m *Dyeing) XXX_DiscardUnknown() {
	xxx_messageInfo_Dyeing.DiscardUnknown(m)
}

var xxx_messageInfo_Dyeing proto.InternalMessageInfo

func (m *Dyeing) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Dyeing) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// Resource 资源信息，在 SDK 运行期间不会改变。
// 各个字段详细定义见：https://galiosight.ai/galio-sdk-go/proto/omp.yaml
type Resource struct {
	// Target 观测对象的唯一标识 ID，需要全局唯一，如：PCG-123.galileo.metaserver
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target" yaml:"target"`
	// Namespace 物理环境，如：Development
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace" yaml:"namespace"`
	// EnvName 用户环境，如：test
	EnvName string `protobuf:"bytes,3,opt,name=env_name,json=envName,proto3" json:"env_name" yaml:"env_name"`
	// Region 地域，如：sz
	Region string `protobuf:"bytes,4,opt,name=region,proto3" json:"region" yaml:"region"`
	// Instance 实例，如：10.20.30.40
	Instance string `protobuf:"bytes,5,opt,name=instance,proto3" json:"instance" yaml:"instance"`
	// Node 节点，如：cls-as9z3nec-be39e3191ce2086271cf0679c0c0f5fc-2
	Node string `protobuf:"bytes,6,opt,name=node,proto3" json:"node" yaml:"node"`
	// ContainerName 容器，如：test.galileo.metaserver.sz100012
	ContainerName string `protobuf:"bytes,7,opt,name=container_name,json=containerName,proto3" json:"container_name" yaml:"container_name"`
	// Version 伽利略 SDK 的版本号。
	Version string `protobuf:"bytes,8,opt,name=version,proto3" json:"version" yaml:"version"`
	// Platform 服务部署的平台，如 PCG-123
	Platform string `protobuf:"bytes,9,opt,name=platform,proto3" json:"platform" yaml:"platform"`
	// ObjectName 观测对象名。
	ObjectName string `protobuf:"bytes,10,opt,name=object_name,json=objectName,proto3" json:"object_name" yaml:"object_name"`
	// App 业务名，如 galileo。
	App string `protobuf:"bytes,11,opt,name=app,proto3" json:"app" yaml:"app"`
	// Server 服务名，如 metaserver。
	Server string `protobuf:"bytes,12,opt,name=server,proto3" json:"server" yaml:"server"`
	// SetName 分 set 时的 set 名，如 set.sz.1
	SetName string `protobuf:"bytes,13,opt,name=set_name,json=setName,proto3" json:"set_name" yaml:"set_name"`
	// FrameCode 框架代号，如 trpc
	FrameCode string `protobuf:"bytes,14,opt,name=frame_code,json=frameCode,proto3" json:"frame_code" yaml:"frame_code"`
	// ServiceName 服务默认 ServiceName，由 ClientFilter
	// 传递给下游，用于修复主调方没有正确传递主调服务名的场景。通常是点分 4
	// 段格式，如 trpc.galileo.metaserver.Service。
	ServiceName string `protobuf:"bytes,15,opt,name=service_name,json=serviceName,proto3" json:"service_name" yaml:"service_name"`
	// TenantID 租户 ID。
	TenantId string `protobuf:"bytes,16,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id" yaml:"tenant_id"`
	// CmdbID cmdb ID。
	CmdbId string `protobuf:"bytes,17,opt,name=cmdb_id,json=cmdbId,proto3" json:"cmdb_id" yaml:"cmdb_id"`
	// TargetType 观测对象类型
	TargetType int32 `protobuf:"varint,18,opt,name=target_type,json=targetType,proto3" json:"target_type" yaml:"target_type"`
	// Language 开发语言
	Language string `protobuf:"bytes,20,opt,name=language,proto3" json:"language" yaml:"language"`
	// SdkName SDK 名
	SdkName string `protobuf:"bytes,21,opt,name=sdk_name,json=sdkName,proto3" json:"sdk_name" yaml:"sdk_name"`
	// City 服务器所在城市
	City string `protobuf:"bytes,22,opt,name=city,proto3" json:"city" yaml:"city"`
	// Admin 端口
	AdminPort uint32 `protobuf:"varint,23,opt,name=admin_port,json=adminPort,proto3" json:"admin_port" yaml:"admin_port"`
	// 发布版本，每次发布变更都应该有不同的版本，可以使用镜像版本、commit id 等来表示，此字段用于 CD 发布时，对比不同版本的指标数据
	ReleaseVersion string `protobuf:"bytes,24,opt,name=release_version,json=releaseVersion,proto3" json:"release_version" yaml:"release_version"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{28}
}
func (m *Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return m.Size()
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

func (m *Resource) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Resource) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Resource) GetEnvName() string {
	if m != nil {
		return m.EnvName
	}
	return ""
}

func (m *Resource) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Resource) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *Resource) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *Resource) GetContainerName() string {
	if m != nil {
		return m.ContainerName
	}
	return ""
}

func (m *Resource) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Resource) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *Resource) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *Resource) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *Resource) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *Resource) GetSetName() string {
	if m != nil {
		return m.SetName
	}
	return ""
}

func (m *Resource) GetFrameCode() string {
	if m != nil {
		return m.FrameCode
	}
	return ""
}

func (m *Resource) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Resource) GetTenantId() string {
	if m != nil {
		return m.TenantId
	}
	return ""
}

func (m *Resource) GetCmdbId() string {
	if m != nil {
		return m.CmdbId
	}
	return ""
}

func (m *Resource) GetTargetType() int32 {
	if m != nil {
		return m.TargetType
	}
	return 0
}

func (m *Resource) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Resource) GetSdkName() string {
	if m != nil {
		return m.SdkName
	}
	return ""
}

func (m *Resource) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *Resource) GetAdminPort() uint32 {
	if m != nil {
		return m.AdminPort
	}
	return 0
}

func (m *Resource) GetReleaseVersion() string {
	if m != nil {
		return m.ReleaseVersion
	}
	return ""
}

// 指标 Schema 定义
type MetricSchema struct {
	// 监控项
	MonitorName string `protobuf:"bytes,1,opt,name=monitor_name,json=monitorName,proto3" json:"monitor_name" yaml:"monitor_name"`
	// 指标名
	MetricName string `protobuf:"bytes,2,opt,name=metric_name,json=metricName,proto3" json:"metric_name" yaml:"metric_name"`
	// 指标类型
	MetricType string `protobuf:"bytes,3,opt,name=metric_type,json=metricType,proto3" json:"metric_type" yaml:"metric_type"`
	// 指标聚合方式
	Aggregation string `protobuf:"bytes,4,opt,name=aggregation,proto3" json:"aggregation" yaml:"aggregation"`
	// 指标别名
	MetricAlias string `protobuf:"bytes,5,opt,name=metric_alias,json=metricAlias,proto3" json:"metric_alias" yaml:"metric_alias"`
	// 指标描述
	MetricDesc string `protobuf:"bytes,6,opt,name=metric_desc,json=metricDesc,proto3" json:"metric_desc" yaml:"metric_desc"`
	// 标签列表
	Labels []string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels" yaml:"labels"`
	// Usage 指标用法 (sum,count,max,min)。
	Usage string `protobuf:"bytes,8,opt,name=usage,proto3" json:"usage" yaml:"usage"`
}

func (m *MetricSchema) Reset()         { *m = MetricSchema{} }
func (m *MetricSchema) String() string { return proto.CompactTextString(m) }
func (*MetricSchema) ProtoMessage()    {}
func (*MetricSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{29}
}
func (m *MetricSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSchema.Merge(m, src)
}
func (m *MetricSchema) XXX_Size() int {
	return m.Size()
}
func (m *MetricSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSchema.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSchema proto.InternalMessageInfo

func (m *MetricSchema) GetMonitorName() string {
	if m != nil {
		return m.MonitorName
	}
	return ""
}

func (m *MetricSchema) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *MetricSchema) GetMetricType() string {
	if m != nil {
		return m.MetricType
	}
	return ""
}

func (m *MetricSchema) GetAggregation() string {
	if m != nil {
		return m.Aggregation
	}
	return ""
}

func (m *MetricSchema) GetMetricAlias() string {
	if m != nil {
		return m.MetricAlias
	}
	return ""
}

func (m *MetricSchema) GetMetricDesc() string {
	if m != nil {
		return m.MetricDesc
	}
	return ""
}

func (m *MetricSchema) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *MetricSchema) GetUsage() string {
	if m != nil {
		return m.Usage
	}
	return ""
}

// 日志 Schema 定义
type LogSchema struct {
	// 日志名
	LogName string `protobuf:"bytes,1,opt,name=log_name,json=logName,proto3" json:"log_name" yaml:"log_name"`
	// 标签列表
	Labels []string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels" yaml:"labels"`
}

func (m *LogSchema) Reset()         { *m = LogSchema{} }
func (m *LogSchema) String() string { return proto.CompactTextString(m) }
func (*LogSchema) ProtoMessage()    {}
func (*LogSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{30}
}
func (m *LogSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSchema.Merge(m, src)
}
func (m *LogSchema) XXX_Size() int {
	return m.Size()
}
func (m *LogSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSchema.DiscardUnknown(m)
}

var xxx_messageInfo_LogSchema proto.InternalMessageInfo

func (m *LogSchema) GetLogName() string {
	if m != nil {
		return m.LogName
	}
	return ""
}

func (m *LogSchema) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// 追踪 Schema 定义
type TraceSchema struct {
	// 标签列表
	Labels []string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels" yaml:"labels"`
}

func (m *TraceSchema) Reset()         { *m = TraceSchema{} }
func (m *TraceSchema) String() string { return proto.CompactTextString(m) }
func (*TraceSchema) ProtoMessage()    {}
func (*TraceSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{31}
}
func (m *TraceSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraceSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraceSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceSchema.Merge(m, src)
}
func (m *TraceSchema) XXX_Size() int {
	return m.Size()
}
func (m *TraceSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceSchema.DiscardUnknown(m)
}

var xxx_messageInfo_TraceSchema proto.InternalMessageInfo

func (m *TraceSchema) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Profile Schema 定义
type ProfileSchema struct {
	// profile 类型
	ProfileType string `protobuf:"bytes,1,opt,name=profile_type,json=profileType,proto3" json:"profile_type" yaml:"profile_type"`
	// 标签列表
	Labels []string `protobuf:"bytes,7,rep,name=labels,proto3" json:"labels" yaml:"labels"`
}

func (m *ProfileSchema) Reset()         { *m = ProfileSchema{} }
func (m *ProfileSchema) String() string { return proto.CompactTextString(m) }
func (*ProfileSchema) ProtoMessage()    {}
func (*ProfileSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{32}
}
func (m *ProfileSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfileSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfileSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfileSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfileSchema.Merge(m, src)
}
func (m *ProfileSchema) XXX_Size() int {
	return m.Size()
}
func (m *ProfileSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfileSchema.DiscardUnknown(m)
}

var xxx_messageInfo_ProfileSchema proto.InternalMessageInfo

func (m *ProfileSchema) GetProfileType() string {
	if m != nil {
		return m.ProfileType
	}
	return ""
}

func (m *ProfileSchema) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// TelemetrySchemaRequest 上报观测数据 schema 的请求。
// 请求 POST /ocp/api/v1/telemetry_schema
// 通常是聚合一段时间后，定时上报。
// Schema 未发生变化的情况下，不需要上报。
type TelemetrySchemaRequest struct {
	// 资源
	Resource Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource" yaml:"resource"`
	// 请求序列号，每次进程启动后，从 0 开始自增
	SerialNumber uint64 `protobuf:"varint,2,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number" yaml:"serial_number"`
	// 指标 Schema 定义
	MetricSchemas []MetricSchema `protobuf:"bytes,3,rep,name=metric_schemas,json=metricSchemas,proto3" json:"metric_schemas" yaml:"metric_schemas"`
	// 追踪 Schema 定义
	TraceSchemas []TraceSchema `protobuf:"bytes,4,rep,name=trace_schemas,json=traceSchemas,proto3" json:"trace_schemas" yaml:"trace_schemas"`
	// 日志 Schema 定义
	LogSchemas []LogSchema `protobuf:"bytes,5,rep,name=log_schemas,json=logSchemas,proto3" json:"log_schemas" yaml:"log_schemas"`
	// Profile Schema 定义
	ProfileSchemas []ProfileSchema `protobuf:"bytes,6,rep,name=profile_schemas,json=profileSchemas,proto3" json:"profile_schemas" yaml:"profile_schemas"`
}

func (m *TelemetrySchemaRequest) Reset()         { *m = TelemetrySchemaRequest{} }
func (m *TelemetrySchemaRequest) String() string { return proto.CompactTextString(m) }
func (*TelemetrySchemaRequest) ProtoMessage()    {}
func (*TelemetrySchemaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{33}
}
func (m *TelemetrySchemaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetrySchemaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetrySchemaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetrySchemaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetrySchemaRequest.Merge(m, src)
}
func (m *TelemetrySchemaRequest) XXX_Size() int {
	return m.Size()
}
func (m *TelemetrySchemaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetrySchemaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetrySchemaRequest proto.InternalMessageInfo

func (m *TelemetrySchemaRequest) GetResource() Resource {
	if m != nil {
		return m.Resource
	}
	return Resource{}
}

func (m *TelemetrySchemaRequest) GetSerialNumber() uint64 {
	if m != nil {
		return m.SerialNumber
	}
	return 0
}

func (m *TelemetrySchemaRequest) GetMetricSchemas() []MetricSchema {
	if m != nil {
		return m.MetricSchemas
	}
	return nil
}

func (m *TelemetrySchemaRequest) GetTraceSchemas() []TraceSchema {
	if m != nil {
		return m.TraceSchemas
	}
	return nil
}

func (m *TelemetrySchemaRequest) GetLogSchemas() []LogSchema {
	if m != nil {
		return m.LogSchemas
	}
	return nil
}

func (m *TelemetrySchemaRequest) GetProfileSchemas() []ProfileSchema {
	if m != nil {
		return m.ProfileSchemas
	}
	return nil
}

// TelemetrySchemaResponse 上报观测数据 schema 的回包。
type TelemetrySchemaResponse struct {
	// 返回码
	Code int32 `protobuf:"varint,1,opt,name=code,proto3" json:"code" yaml:"code"`
	// 返回信息
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg" yaml:"msg"`
}

func (m *TelemetrySchemaResponse) Reset()         { *m = TelemetrySchemaResponse{} }
func (m *TelemetrySchemaResponse) String() string { return proto.CompactTextString(m) }
func (*TelemetrySchemaResponse) ProtoMessage()    {}
func (*TelemetrySchemaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{34}
}
func (m *TelemetrySchemaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetrySchemaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetrySchemaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetrySchemaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetrySchemaResponse.Merge(m, src)
}
func (m *TelemetrySchemaResponse) XXX_Size() int {
	return m.Size()
}
func (m *TelemetrySchemaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetrySchemaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetrySchemaResponse proto.InternalMessageInfo

func (m *TelemetrySchemaResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TelemetrySchemaResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type BloomDyeing struct {
	// 染色的 key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key" yaml:"key"`
	// 布隆过滤器大小
	BitSize int32 `protobuf:"varint,2,opt,name=bit_size,json=bitSize,proto3" json:"bit_size" yaml:"bit_size"`
	// 布隆过滤器哈希函数数量
	HashNumber int32 `protobuf:"varint,3,opt,name=hash_number,json=hashNumber,proto3" json:"hash_number" yaml:"hash_number"`
	// 布隆过滤器 bitmap 数据
	Bitmap []int64 `protobuf:"varint,4,rep,packed,name=bitmap,proto3" json:"bitmap" yaml:"bitmap"`
}

func (m *BloomDyeing) Reset()         { *m = BloomDyeing{} }
func (m *BloomDyeing) String() string { return proto.CompactTextString(m) }
func (*BloomDyeing) ProtoMessage()    {}
func (*BloomDyeing) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{35}
}
func (m *BloomDyeing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BloomDyeing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BloomDyeing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BloomDyeing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BloomDyeing.Merge(m, src)
}
func (m *BloomDyeing) XXX_Size() int {
	return m.Size()
}
func (m *BloomDyeing) XXX_DiscardUnknown() {
	xxx_messageInfo_BloomDyeing.DiscardUnknown(m)
}

var xxx_messageInfo_BloomDyeing proto.InternalMessageInfo

func (m *BloomDyeing) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *BloomDyeing) GetBitSize() int32 {
	if m != nil {
		return m.BitSize
	}
	return 0
}

func (m *BloomDyeing) GetHashNumber() int32 {
	if m != nil {
		return m.HashNumber
	}
	return 0
}

func (m *BloomDyeing) GetBitmap() []int64 {
	if m != nil {
		return m.Bitmap
	}
	return nil
}

// RpcSamplingConfig 主被调采样配置。
type RpcSamplingConfig struct {
	// 采样率，默认 -1，此时继承 SamplerConfig.fraction。设置成 0 即可关闭随机采样。
	Fraction float64 `protobuf:"fixed64,1,opt,name=fraction,proto3" json:"fraction" yaml:"fraction"`
	// 接口级采样配置。
	Rpc []RpcConfig `protobuf:"bytes,2,rep,name=rpc,proto3" json:"rpc" yaml:"rpc"`
}

func (m *RpcSamplingConfig) Reset()         { *m = RpcSamplingConfig{} }
func (m *RpcSamplingConfig) String() string { return proto.CompactTextString(m) }
func (*RpcSamplingConfig) ProtoMessage()    {}
func (*RpcSamplingConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{36}
}
func (m *RpcSamplingConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcSamplingConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcSamplingConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcSamplingConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcSamplingConfig.Merge(m, src)
}
func (m *RpcSamplingConfig) XXX_Size() int {
	return m.Size()
}
func (m *RpcSamplingConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcSamplingConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RpcSamplingConfig proto.InternalMessageInfo

func (m *RpcSamplingConfig) GetFraction() float64 {
	if m != nil {
		return m.Fraction
	}
	return 0
}

func (m *RpcSamplingConfig) GetRpc() []RpcConfig {
	if m != nil {
		return m.Rpc
	}
	return nil
}

// RpcConfig 主被调接口级采样配置。
type RpcConfig struct {
	// 接口名称。
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	// 采样率，默认 -1，此时继承 SamplerConfig.RpcSamplingConfig.fraction。设置成 0 即可关闭随机采样。
	Fraction float64 `protobuf:"fixed64,2,opt,name=fraction,proto3" json:"fraction" yaml:"fraction"`
}

func (m *RpcConfig) Reset()         { *m = RpcConfig{} }
func (m *RpcConfig) String() string { return proto.CompactTextString(m) }
func (*RpcConfig) ProtoMessage()    {}
func (*RpcConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_95e63dd5714d69d6, []int{37}
}
func (m *RpcConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcConfig.Merge(m, src)
}
func (m *RpcConfig) XXX_Size() int {
	return m.Size()
}
func (m *RpcConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RpcConfig proto.InternalMessageInfo

func (m *RpcConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RpcConfig) GetFraction() float64 {
	if m != nil {
		return m.Fraction
	}
	return 0
}

func init() {
	proto.RegisterEnum("model.TelemetryData", TelemetryData_name, TelemetryData_value)
	proto.RegisterEnum("model.DataProtocol", DataProtocol_name, DataProtocol_value)
	proto.RegisterEnum("model.DataTransmission", DataTransmission_name, DataTransmission_value)
	proto.RegisterEnum("model.MetricsSampleType", MetricsSampleType_name, MetricsSampleType_value)
	proto.RegisterEnum("model.AccessPoint", AccessPoint_name, AccessPoint_value)
	proto.RegisterType((*Collector)(nil), "model.Collector")
	proto.RegisterType((*GetConfigRequest)(nil), "model.GetConfigRequest")
	proto.RegisterType((*CollectorProtocol)(nil), "model.CollectorProtocol")
	proto.RegisterType((*GetConfigResponse)(nil), "model.GetConfigResponse")
	proto.RegisterType((*SelfMonitor)(nil), "model.SelfMonitor")
	proto.RegisterType((*MetricsConfig)(nil), "model.MetricsConfig")
	proto.RegisterType((*LabelIgnore)(nil), "model.LabelIgnore")
	proto.RegisterType((*SecondGranularity)(nil), "model.SecondGranularity")
	proto.RegisterType((*SampleMonitor)(nil), "model.SampleMonitor")
	proto.RegisterType((*RPCHasTwoIP)(nil), "model.RPCHasTwoIP")
	proto.RegisterType((*MetricsProcessor)(nil), "model.MetricsProcessor")
	proto.RegisterType((*MetricsExporter)(nil), "model.MetricsExporter")
	proto.RegisterType((*PrometheusPushConfig)(nil), "model.PrometheusPushConfig")
	proto.RegisterMapType((map[string]string)(nil), "model.PrometheusPushConfig.GroupingEntry")
	proto.RegisterMapType((map[string]string)(nil), "model.PrometheusPushConfig.HttpHeadersEntry")
	proto.RegisterType((*OpenTelemetryPushConfig)(nil), "model.OpenTelemetryPushConfig")
	proto.RegisterType((*HistogramBucket)(nil), "model.HistogramBucket")
	proto.RegisterType((*TracesConfig)(nil), "model.TracesConfig")
	proto.RegisterType((*TracesProcessor)(nil), "model.TracesProcessor")
	proto.RegisterType((*TracesExporter)(nil), "model.TracesExporter")
	proto.RegisterType((*LogsConfig)(nil), "model.LogsConfig")
	proto.RegisterType((*LogsProcessor)(nil), "model.LogsProcessor")
	proto.RegisterType((*LogsExporter)(nil), "model.LogsExporter")
	proto.RegisterType((*ProfilesConfig)(nil), "model.ProfilesConfig")
	proto.RegisterType((*ProfilesProcessor)(nil), "model.ProfilesProcessor")
	proto.RegisterType((*ProfilesExporter)(nil), "model.ProfilesExporter")
	proto.RegisterType((*SamplerConfig)(nil), "model.SamplerConfig")
	proto.RegisterType((*WorkflowSamplerConfig)(nil), "model.WorkflowSamplerConfig")
	proto.RegisterType((*TokenBucketConfig)(nil), "model.TokenBucketConfig")
	proto.RegisterType((*Dyeing)(nil), "model.Dyeing")
	proto.RegisterType((*Resource)(nil), "model.Resource")
	proto.RegisterType((*MetricSchema)(nil), "model.MetricSchema")
	proto.RegisterType((*LogSchema)(nil), "model.LogSchema")
	proto.RegisterType((*TraceSchema)(nil), "model.TraceSchema")
	proto.RegisterType((*ProfileSchema)(nil), "model.ProfileSchema")
	proto.RegisterType((*TelemetrySchemaRequest)(nil), "model.TelemetrySchemaRequest")
	proto.RegisterType((*TelemetrySchemaResponse)(nil), "model.TelemetrySchemaResponse")
	proto.RegisterType((*BloomDyeing)(nil), "model.BloomDyeing")
	proto.RegisterType((*RpcSamplingConfig)(nil), "model.RpcSamplingConfig")
	proto.RegisterType((*RpcConfig)(nil), "model.RpcConfig")
}

func init() { proto.RegisterFile("ocp.proto", fileDescriptor_95e63dd5714d69d6) }

var fileDescriptor_95e63dd5714d69d6 = []byte{
	// 3576 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x3a, 0x4d, 0x6f, 0x24, 0x49,
	0x56, 0x5d, 0xae, 0x2a, 0xbb, 0xea, 0xd5, 0x87, 0xd3, 0xd1, 0xfe, 0xa8, 0xee, 0xe9, 0xe9, 0x8f,
	0x9a, 0x19, 0xb6, 0x69, 0x56, 0xde, 0x59, 0xb3, 0xb3, 0xd3, 0x33, 0x0d, 0x33, 0xb8, 0xed, 0xea,
	0x6e, 0xb7, 0xca, 0x76, 0x91, 0x55, 0x3b, 0xab, 0xe1, 0x92, 0xca, 0xca, 0x0c, 0x57, 0xe5, 0x3a,
	0x2b, 0x33, 0x89, 0x88, 0xb2, 0xdb, 0x7b, 0x07, 0x84, 0x84, 0x10, 0x42, 0x42, 0x02, 0xc1, 0x85,
	0x1b, 0x07, 0xb8, 0x23, 0x24, 0x24, 0x4e, 0x68, 0x8e, 0x7b, 0xdc, 0x13, 0x82, 0x99, 0x1b, 0x07,
	0xf8, 0x07, 0x08, 0xc5, 0x8b, 0x88, 0xac, 0xcc, 0x2a, 0xdb, 0xed, 0x05, 0x16, 0x24, 0xf6, 0x96,
	0xf1, 0xbe, 0x22, 0xe2, 0x7d, 0xc4, 0x7b, 0xf1, 0x22, 0xa1, 0x1a, 0x7b, 0xc9, 0x76, 0xc2, 0x62,
	0x11, 0x93, 0xf2, 0x24, 0xf6, 0x69, 0x78, 0x77, 0x7d, 0x14, 0x8f, 0x62, 0x84, 0x7c, 0x47, 0x7e,
	0x29, 0x64, 0xfb, 0x2f, 0x96, 0xa0, 0xba, 0x17, 0x87, 0x21, 0xf5, 0x44, 0xcc, 0x08, 0x81, 0x92,
	0xeb, 0xfb, 0xac, 0x55, 0x78, 0x58, 0x78, 0x5c, 0xb5, 0xf1, 0x9b, 0x3c, 0x83, 0xa6, 0xa0, 0x21,
	0x9d, 0x50, 0xc1, 0x2e, 0x1c, 0xdf, 0x15, 0x6e, 0x6b, 0xe9, 0x61, 0xe1, 0x71, 0x73, 0x67, 0x7d,
	0x1b, 0xe5, 0x6e, 0x0f, 0x0c, 0x72, 0xdf, 0x15, 0xae, 0xdd, 0x10, 0xd9, 0x21, 0x79, 0x0a, 0x0d,
	0xc9, 0xe2, 0xe0, 0x64, 0x5e, 0x1c, 0xb6, 0x8a, 0xc8, 0x7b, 0x5b, 0xf3, 0x4a, 0x9a, 0x9e, 0x46,
	0xd9, 0x75, 0x3f, 0x33, 0x22, 0xfb, 0xb0, 0x86, 0x9c, 0x82, 0xb9, 0x11, 0x9f, 0x04, 0x9c, 0x07,
	0x71, 0xd4, 0x2a, 0x21, 0xf7, 0x56, 0x86, 0x7b, 0x90, 0x41, 0xdb, 0x96, 0x3f, 0x07, 0x21, 0x2d,
	0x58, 0x39, 0xa3, 0x0c, 0x79, 0xcb, 0x0f, 0x0b, 0x8f, 0xcb, 0xb6, 0x19, 0x92, 0xf7, 0xa1, 0xe9,
	0x07, 0x8c, 0x7a, 0xc2, 0x09, 0x12, 0x27, 0x89, 0x99, 0x68, 0x2d, 0x3f, 0x2c, 0x3e, 0xae, 0xda,
	0x75, 0x05, 0x3d, 0x48, 0x7a, 0x31, 0x13, 0xed, 0xbf, 0x2d, 0x82, 0xf5, 0x92, 0x8a, 0xbd, 0x38,
	0x3a, 0x09, 0x46, 0x36, 0xfd, 0xed, 0x29, 0xe5, 0x82, 0xdc, 0x85, 0x4a, 0x12, 0xba, 0xe2, 0x24,
	0x66, 0x13, 0xad, 0xa9, 0x74, 0x4c, 0x1e, 0x40, 0x2d, 0x1e, 0xfe, 0x48, 0x8a, 0x8d, 0xdc, 0x09,
	0x45, 0x55, 0x55, 0x6d, 0x50, 0xa0, 0x23, 0x77, 0x42, 0xc9, 0x53, 0x58, 0x91, 0xea, 0x09, 0x3c,
	0x8e, 0xba, 0xa8, 0xed, 0xb4, 0xf4, 0x6e, 0x52, 0x2b, 0x18, 0x15, 0x3c, 0x2f, 0x7d, 0xf5, 0x4f,
	0x0f, 0x6e, 0xd9, 0x86, 0x9c, 0x7c, 0x1f, 0x96, 0x05, 0x73, 0x3d, 0xca, 0x51, 0x0d, 0x6f, 0x67,
	0xd4, 0xd4, 0x64, 0x07, 0x4a, 0x61, 0x3c, 0xe2, 0xa8, 0x80, 0xb7, 0x73, 0x21, 0x2d, 0xb1, 0xa0,
	0x48, 0xa3, 0xb3, 0xd6, 0x32, 0x2e, 0x5f, 0x7e, 0x4a, 0x08, 0xa7, 0xa2, 0xb5, 0xa2, 0x20, 0x9c,
	0x0a, 0xf2, 0x5d, 0xa8, 0x30, 0xca, 0xe3, 0x29, 0xf3, 0x68, 0xab, 0x82, 0xb2, 0x57, 0xb5, 0x6c,
	0x5b, 0x83, 0xb5, 0xc8, 0x94, 0x8c, 0x7c, 0x0a, 0x95, 0x84, 0xc5, 0x27, 0x41, 0x48, 0x79, 0xab,
	0x7a, 0xa3, 0xe5, 0xa4, 0xf4, 0x64, 0x1b, 0xca, 0x61, 0xec, 0xb9, 0x61, 0x0b, 0x72, 0x8c, 0x19,
	0xeb, 0xf0, 0x24, 0x8e, 0x38, 0xb5, 0x15, 0x59, 0xfb, 0x5f, 0x0b, 0xb0, 0xb6, 0x20, 0xf5, 0xff,
	0xa9, 0x37, 0xb7, 0xff, 0xad, 0x0c, 0x6b, 0x0b, 0x9a, 0x90, 0xe1, 0xec, 0xc5, 0x3e, 0x45, 0x27,
	0x2d, 0xdb, 0xf8, 0x2d, 0xed, 0x38, 0xe1, 0x23, 0xed, 0x98, 0xf2, 0x93, 0x6c, 0xc2, 0xb2, 0x70,
	0xd9, 0x88, 0x0a, 0xdc, 0x4e, 0xd5, 0xd6, 0x23, 0xf2, 0x1e, 0x34, 0x3c, 0x94, 0xe7, 0x70, 0xca,
	0xce, 0x28, 0xc3, 0xf5, 0x56, 0xed, 0xba, 0x02, 0xf6, 0x11, 0x46, 0xbe, 0x05, 0xab, 0x8c, 0x8e,
	0x02, 0x2e, 0x28, 0x33, 0x64, 0x65, 0x24, 0x6b, 0x1a, 0xb0, 0x26, 0x7c, 0x06, 0x75, 0x4e, 0xc3,
	0x13, 0x67, 0x12, 0x47, 0x81, 0x88, 0x19, 0xba, 0x56, 0x6d, 0x87, 0xe8, 0xcd, 0xf7, 0x69, 0x78,
	0x72, 0xa8, 0x30, 0xda, 0xf0, 0x35, 0x3e, 0x03, 0x91, 0x5d, 0x68, 0xea, 0x28, 0x70, 0xd4, 0xec,
	0xe8, 0x87, 0xb5, 0xd4, 0x6a, 0x87, 0x0a, 0xa9, 0xb6, 0xaf, 0x05, 0x34, 0x26, 0x59, 0x20, 0xf9,
	0x0c, 0x1a, 0x2a, 0x1e, 0x8c, 0x04, 0xe5, 0xb2, 0xc6, 0x76, 0x03, 0xc4, 0xe5, 0x04, 0xd4, 0x45,
	0x06, 0x46, 0x9e, 0x42, 0x4d, 0x46, 0x86, 0xe1, 0x56, 0xde, 0xbb, 0xa6, 0xb9, 0xbb, 0xf1, 0x28,
	0xcf, 0x0b, 0x61, 0x0a, 0x21, 0xef, 0x40, 0x55, 0xd0, 0xc8, 0x8d, 0x84, 0x13, 0xf8, 0xe8, 0xbc,
	0x55, 0xbb, 0xa2, 0x00, 0x07, 0x7e, 0xd6, 0xa4, 0xb5, 0xfc, 0x01, 0xb5, 0x0f, 0xab, 0xc6, 0xf7,
	0xcd, 0xa4, 0x75, 0x9c, 0x74, 0x43, 0x4f, 0xda, 0xd3, 0xd8, 0xdc, 0xc4, 0xcd, 0x24, 0x07, 0x25,
	0x1f, 0x41, 0xdd, 0xf5, 0x3c, 0xca, 0xb9, 0x93, 0xc4, 0x41, 0x24, 0x5a, 0x0d, 0xf4, 0x39, 0xa3,
	0xf6, 0x5d, 0x44, 0xf5, 0x24, 0xc6, 0xae, 0xb9, 0xb3, 0x01, 0x79, 0x8d, 0x93, 0x4f, 0xa8, 0x18,
	0xd3, 0x29, 0x77, 0x92, 0x29, 0x1f, 0xb7, 0x9a, 0x38, 0xf9, 0x3b, 0xb3, 0xc9, 0x35, 0xb6, 0x37,
	0xe5, 0xe3, 0x85, 0x25, 0x64, 0x70, 0xa4, 0x0f, 0x24, 0x4e, 0x68, 0x34, 0x0b, 0x3b, 0x14, 0xb7,
	0x8a, 0xe2, 0xee, 0x6b, 0x71, 0xc7, 0x09, 0x8d, 0xd2, 0xd0, 0x5b, 0x90, 0xb8, 0x96, 0xe3, 0x97,
	0xe8, 0xf6, 0xef, 0x16, 0xa0, 0x96, 0x71, 0x1a, 0x3c, 0x93, 0x4d, 0x54, 0x9a, 0x33, 0xd9, 0x04,
	0xdf, 0xf7, 0xa0, 0xea, 0x99, 0x83, 0x00, 0x1d, 0xbf, 0xb6, 0x63, 0xcd, 0x1f, 0x3b, 0x7a, 0xa6,
	0x19, 0x21, 0xf9, 0x00, 0x9a, 0x8c, 0xca, 0xc4, 0xe0, 0x70, 0xea, 0xc5, 0x91, 0xaf, 0xce, 0xeb,
	0xb2, 0xdd, 0x50, 0xd0, 0xbe, 0x02, 0xb6, 0xff, 0xbe, 0x00, 0x8d, 0x9c, 0xfb, 0xc9, 0x78, 0xa2,
	0x91, 0x3b, 0x0c, 0x55, 0xdc, 0x55, 0x6c, 0x3d, 0x22, 0xcf, 0xa0, 0x9a, 0xb0, 0x58, 0xea, 0x38,
	0x66, 0xfa, 0xec, 0xdf, 0xca, 0xfb, 0x6f, 0xcf, 0xa0, 0xcd, 0x6a, 0x52, 0x7a, 0xf2, 0x14, 0x2a,
	0xf4, 0x8d, 0x9c, 0x57, 0xc7, 0x61, 0x6d, 0x67, 0x33, 0xcf, 0xdb, 0xd1, 0x58, 0x73, 0x6e, 0x1a,
	0x6a, 0xf2, 0x2e, 0x80, 0x5a, 0x80, 0xc3, 0x39, 0xc5, 0xe0, 0xac, 0xd8, 0x55, 0x05, 0xe9, 0x73,
	0xda, 0xfe, 0x4d, 0xa8, 0x75, 0xdd, 0x21, 0x0d, 0x0f, 0x46, 0x51, 0xcc, 0x28, 0x79, 0x04, 0x75,
	0x1d, 0xa1, 0x2a, 0x81, 0x29, 0x5d, 0xd6, 0x34, 0x0c, 0x33, 0xd8, 0x03, 0xa8, 0x85, 0x92, 0x03,
	0x09, 0x78, 0x6b, 0x09, 0xd3, 0x26, 0x20, 0x48, 0xe2, 0x79, 0xfb, 0x1f, 0x0a, 0xb0, 0xa6, 0xd4,
	0xf3, 0x92, 0xb9, 0xd1, 0x34, 0x74, 0x59, 0x20, 0x2e, 0x6e, 0x22, 0xf9, 0x11, 0xd4, 0x87, 0x74,
	0x14, 0x44, 0x5a, 0xe3, 0x68, 0xab, 0xa2, 0x5d, 0x43, 0x98, 0x12, 0xa8, 0x76, 0xe3, 0x1b, 0x82,
	0x22, 0x12, 0x54, 0x69, 0xe4, 0x6b, 0xf4, 0x07, 0xd0, 0x3c, 0x0f, 0x22, 0x3f, 0x3e, 0x4f, 0x8d,
	0x56, 0x52, 0x46, 0x53, 0x50, 0x6d, 0x34, 0xb9, 0x05, 0x21, 0xc2, 0x94, 0xa6, 0x8c, 0x62, 0x40,
	0x88, 0xd0, 0x58, 0xf5, 0xf7, 0x0b, 0xd0, 0xe8, 0xbb, 0x93, 0x24, 0xa4, 0xc6, 0xc1, 0x6e, 0xb0,
	0xfc, 0x4f, 0xa0, 0xc6, 0x91, 0xc7, 0x11, 0x17, 0x09, 0xd5, 0x89, 0xa5, 0x95, 0x37, 0x93, 0x12,
	0x3a, 0xb8, 0x48, 0xa8, 0x0d, 0x3c, 0xfd, 0x96, 0xee, 0x7b, 0xc2, 0x5c, 0x4f, 0xc8, 0x73, 0x40,
	0x6e, 0xaa, 0x60, 0xa7, 0xe3, 0x36, 0x83, 0x9a, 0xdd, 0xdb, 0x7b, 0xe5, 0xf2, 0xc1, 0x79, 0x7c,
	0xd0, 0xfb, 0x5f, 0xd1, 0x63, 0xfb, 0x1f, 0xcb, 0x60, 0xcd, 0x3b, 0xe5, 0xb5, 0x31, 0xb6, 0xa8,
	0xf8, 0xa5, 0xcb, 0x14, 0x2f, 0x73, 0x4a, 0x48, 0x5d, 0x36, 0x17, 0x53, 0x75, 0x04, 0x1a, 0xa2,
	0x6f, 0xc1, 0x2a, 0x7d, 0x93, 0x04, 0x8c, 0xf2, 0x9c, 0x15, 0x8b, 0x76, 0x53, 0x83, 0x33, 0x66,
	0xc4, 0x53, 0xcd, 0x09, 0x83, 0x49, 0x20, 0x8c, 0x19, 0x11, 0xd4, 0x95, 0x10, 0xf2, 0x3d, 0xd8,
	0xd4, 0xbe, 0xaf, 0x23, 0xc9, 0x31, 0xb5, 0xd7, 0x32, 0xc6, 0xc1, 0xba, 0xc2, 0xea, 0x2d, 0x1e,
	0xa6, 0x85, 0xd6, 0xd6, 0x1c, 0x79, 0xba, 0x8e, 0x15, 0x9c, 0x62, 0x23, 0xc9, 0x31, 0x98, 0xe5,
	0x1c, 0xc0, 0xda, 0x38, 0xe0, 0x22, 0x1e, 0x31, 0x77, 0xe2, 0x0c, 0xa7, 0xde, 0x29, 0x15, 0xbc,
	0x55, 0x79, 0x58, 0xcc, 0x04, 0xeb, 0x2b, 0x83, 0x7f, 0x8e, 0x68, 0x1d, 0xac, 0xd6, 0x38, 0x0f,
	0xe6, 0xe4, 0xd7, 0xa1, 0xa1, 0x62, 0x2c, 0xc0, 0xb0, 0x94, 0xd5, 0x52, 0x31, 0x93, 0x2e, 0x33,
	0x11, 0x6b, 0x92, 0x55, 0x38, 0x03, 0x71, 0xf2, 0x5d, 0xd8, 0x60, 0x54, 0x38, 0x32, 0xe1, 0x3b,
	0x2e, 0x77, 0xe8, 0x1b, 0x8f, 0x26, 0xe8, 0x5b, 0x80, 0xdb, 0x26, 0x4c, 0x96, 0x0a, 0x3e, 0xdd,
	0xe5, 0x1d, 0x83, 0x21, 0xc7, 0x70, 0x5b, 0x6d, 0xd2, 0x19, 0xcd, 0x82, 0x96, 0xb7, 0x6a, 0x38,
	0x6f, 0x2b, 0x4d, 0xd3, 0x73, 0x51, 0xad, 0x67, 0x27, 0x7c, 0x1e, 0xc1, 0xc9, 0x1e, 0xac, 0xea,
	0x68, 0xd0, 0xae, 0xc9, 0x5b, 0x75, 0x14, 0x66, 0x92, 0x76, 0x2e, 0xbe, 0x4c, 0xee, 0xe0, 0x59,
	0x20, 0x27, 0x9f, 0xc3, 0x2a, 0x4b, 0x3c, 0x67, 0xec, 0x72, 0x47, 0x9c, 0xc7, 0x4e, 0x90, 0xf0,
	0x56, 0x23, 0xa7, 0x89, 0x4c, 0x64, 0x18, 0x4d, 0xb0, 0xc4, 0xd3, 0xa0, 0x84, 0xb7, 0x7f, 0xba,
	0x04, 0xab, 0x73, 0x27, 0xe4, 0xcf, 0x21, 0x57, 0x3c, 0x82, 0xba, 0x18, 0x33, 0xea, 0xfa, 0x8e,
	0x17, 0x4f, 0x23, 0xa1, 0xbd, 0xba, 0xa6, 0x60, 0x7b, 0x12, 0x24, 0x7d, 0x75, 0x38, 0x3d, 0x39,
	0x91, 0x65, 0x52, 0xf0, 0x63, 0xaa, 0x8f, 0x25, 0x50, 0xa0, 0x7e, 0xf0, 0x63, 0x2a, 0xcb, 0x84,
	0xc4, 0x1d, 0x51, 0x85, 0x56, 0xe5, 0x5d, 0x45, 0x02, 0x10, 0xf9, 0x2e, 0x80, 0x08, 0x26, 0x34,
	0x9e, 0x0a, 0x67, 0xa2, 0x9c, 0xb7, 0x6c, 0x57, 0x35, 0xe4, 0x90, 0x5f, 0x12, 0x7d, 0x2b, 0x97,
	0x45, 0xdf, 0x2f, 0xc1, 0xea, 0xc4, 0x7d, 0xe3, 0x30, 0xcc, 0xc2, 0x6a, 0xa5, 0x15, 0x45, 0x37,
	0x71, 0xdf, 0xd8, 0x12, 0xaa, 0xd6, 0xfa, 0x3e, 0x34, 0x55, 0xfa, 0x70, 0x44, 0xec, 0xc8, 0x6a,
	0x02, 0xcb, 0x9d, 0x8a, 0x5d, 0x57, 0xd0, 0x41, 0xfc, 0x22, 0x08, 0x69, 0xfb, 0x5f, 0x8a, 0xb0,
	0x7e, 0x59, 0x19, 0x70, 0x65, 0x02, 0xb4, 0xa0, 0x38, 0x65, 0xa1, 0x29, 0x3d, 0xa7, 0x2c, 0x94,
	0x90, 0x1f, 0xc5, 0x43, 0x5d, 0x77, 0xca, 0x4f, 0x69, 0x9b, 0x20, 0x12, 0x94, 0x9d, 0xb9, 0xa1,
	0xd6, 0x51, 0x3a, 0x96, 0xcb, 0x9a, 0x72, 0xea, 0x0c, 0x5d, 0x1e, 0x78, 0x8e, 0x3b, 0x15, 0x63,
	0x9d, 0xcd, 0xea, 0x53, 0x4e, 0x9f, 0x4b, 0xe0, 0xee, 0x54, 0x8c, 0xa5, 0x84, 0x29, 0xa7, 0x0c,
	0xcf, 0x46, 0x75, 0x7f, 0x49, 0xc7, 0x68, 0x79, 0x97, 0xf3, 0xf3, 0x98, 0xf9, 0xfa, 0x26, 0x93,
	0x8e, 0x49, 0x07, 0x2a, 0x23, 0x16, 0x4f, 0x93, 0x20, 0x1a, 0xe9, 0xa0, 0xfd, 0xe5, 0x6b, 0x6a,
	0x9d, 0xed, 0x97, 0x9a, 0xb6, 0x13, 0x09, 0x76, 0x61, 0xa7, 0xac, 0xe4, 0x18, 0xea, 0x63, 0x21,
	0x12, 0x67, 0x4c, 0x5d, 0x9f, 0x32, 0x13, 0xb8, 0xdf, 0xbe, 0x4e, 0xd4, 0x2b, 0x21, 0x92, 0x57,
	0x8a, 0x5c, 0x49, 0xab, 0x8d, 0x67, 0x90, 0xbb, 0xcf, 0xa0, 0x91, 0x9b, 0x4b, 0x2a, 0xed, 0x94,
	0x5e, 0x68, 0xcf, 0x95, 0x9f, 0x64, 0x1d, 0xca, 0x67, 0x6e, 0x38, 0x35, 0xd7, 0x4d, 0x35, 0xf8,
	0x74, 0xe9, 0x69, 0xe1, 0xee, 0x67, 0x60, 0xcd, 0x4b, 0xff, 0x59, 0xf8, 0xdb, 0x7b, 0xb0, 0x75,
	0x45, 0x69, 0x76, 0x73, 0x2b, 0xb7, 0x3f, 0x87, 0xd5, 0xb9, 0x73, 0x4f, 0xde, 0x4c, 0x32, 0xc9,
	0x0b, 0xbf, 0x65, 0x29, 0x6c, 0x0e, 0x4d, 0x59, 0x53, 0x14, 0x6c, 0x33, 0x6c, 0xff, 0x5d, 0x01,
	0xea, 0xd9, 0x02, 0xfd, 0xca, 0xb9, 0x3f, 0x5d, 0x2c, 0xb1, 0x36, 0x73, 0x05, 0xfe, 0x35, 0x15,
	0xd6, 0xc7, 0x0b, 0x15, 0xd6, 0x46, 0x8e, 0xf5, 0xbf, 0x5a, 0x60, 0xfd, 0x75, 0x09, 0x56, 0xe7,
	0x26, 0x7f, 0xcb, 0x09, 0xb4, 0xa2, 0x0e, 0x41, 0xb3, 0x83, 0xfc, 0x79, 0xc9, 0x72, 0x95, 0xb1,
	0x21, 0x25, 0xdf, 0x06, 0xe2, 0x07, 0x1c, 0x57, 0x81, 0xd7, 0x16, 0x67, 0x18, 0xfb, 0x17, 0xb8,
	0x8f, 0x8a, 0x6d, 0x69, 0x0c, 0xae, 0xe2, 0x79, 0xec, 0x5f, 0x90, 0x4f, 0xe0, 0x8e, 0xa1, 0xe6,
	0x82, 0x51, 0x77, 0x92, 0x65, 0xaa, 0x21, 0xd3, 0xa6, 0x26, 0xe8, 0x23, 0x7e, 0xc6, 0x3a, 0x4b,
	0xa9, 0x3e, 0x3d, 0xa1, 0x8c, 0x51, 0xdf, 0x51, 0x6b, 0xd0, 0x3b, 0xd7, 0x29, 0x75, 0x5f, 0x23,
	0xd5, 0xa2, 0xc9, 0x0e, 0x6c, 0xcc, 0x91, 0x3b, 0x94, 0x31, 0x7d, 0x0d, 0xac, 0xd8, 0xb7, 0xfd,
	0x1c, 0x79, 0x47, 0xa2, 0xc8, 0x0b, 0x78, 0x38, 0xcf, 0xc3, 0xc3, 0xf8, 0xdc, 0xf1, 0xa7, 0xcc,
	0x95, 0x29, 0x4b, 0x9e, 0x84, 0x2a, 0x1f, 0xdf, 0xcb, 0xb3, 0xf7, 0xc3, 0xf8, 0x7c, 0x5f, 0x13,
	0x1d, 0x62, 0x3a, 0x37, 0x9b, 0x4d, 0x5c, 0x46, 0x23, 0xa1, 0xa4, 0xa9, 0x38, 0x97, 0xb3, 0x6f,
	0x68, 0x74, 0x0f, 0xb1, 0x7d, 0x8d, 0x24, 0x87, 0x60, 0x9d, 0xc7, 0xec, 0xf4, 0x44, 0xce, 0x69,
	0x2c, 0xa2, 0xae, 0x7d, 0xf7, 0xb4, 0x45, 0x7e, 0xa8, 0xd1, 0x97, 0x59, 0x66, 0xf5, 0x3c, 0x8f,
	0x94, 0x67, 0xf4, 0xac, 0x16, 0xc1, 0x43, 0x55, 0x25, 0xe3, 0x46, 0x5a, 0x83, 0x48, 0x60, 0xfb,
	0x0f, 0x97, 0xa0, 0x99, 0x77, 0xb8, 0x9f, 0x43, 0xbe, 0xfa, 0xef, 0x25, 0xa3, 0x1b, 0x66, 0x1b,
	0x59, 0x9d, 0xb9, 0x32, 0x80, 0x95, 0x14, 0x95, 0x69, 0x40, 0x81, 0x50, 0xce, 0xcd, 0xd2, 0xcc,
	0x9f, 0x14, 0x00, 0x66, 0xf7, 0xeb, 0x2b, 0x43, 0xff, 0xe9, 0x62, 0xe8, 0xaf, 0x67, 0x6e, 0xe7,
	0xd7, 0x04, 0xfe, 0x47, 0x0b, 0x81, 0x7f, 0x3b, 0xc3, 0x78, 0x55, 0xd8, 0xb7, 0xff, 0x60, 0x09,
	0x1a, 0x39, 0xc9, 0xd7, 0xda, 0xe9, 0x7d, 0x68, 0xc6, 0x51, 0x78, 0xa1, 0xe3, 0x2c, 0x8c, 0x55,
	0x07, 0xa6, 0x62, 0xd7, 0x25, 0x14, 0xed, 0xdd, 0x8d, 0x47, 0x92, 0x2a, 0x25, 0x70, 0xe4, 0x1a,
	0xb4, 0x69, 0x54, 0x2b, 0xa2, 0x1b, 0x8f, 0x0e, 0x63, 0x9f, 0xca, 0xe3, 0x3a, 0xa4, 0x67, 0x34,
	0xd4, 0x9d, 0x16, 0x35, 0xc0, 0xaa, 0x59, 0xf9, 0x17, 0xa3, 0x5e, 0x7c, 0x46, 0xd9, 0x85, 0x0e,
	0x2e, 0xed, 0x76, 0xb6, 0x86, 0x62, 0x15, 0x30, 0xe5, 0x02, 0xe7, 0x40, 0xb9, 0x2a, 0x17, 0x56,
	0xec, 0x86, 0x04, 0x77, 0xe3, 0x11, 0x2e, 0xc7, 0x97, 0x74, 0x33, 0x12, 0x75, 0xa5, 0xa9, 0xe0,
	0x84, 0x8d, 0xd0, 0xd0, 0xc8, 0xbb, 0xcb, 0xeb, 0x52, 0xa5, 0x68, 0x95, 0xa4, 0x3a, 0xea, 0x59,
	0x7d, 0xfd, 0x82, 0x7b, 0xed, 0x5f, 0x16, 0xa0, 0x99, 0x6f, 0xd0, 0x5c, 0xe9, 0xb9, 0xbf, 0xb6,
	0xe8, 0xb9, 0xad, 0xb9, 0x16, 0xcf, 0x35, 0xde, 0xfb, 0xc9, 0x82, 0xf7, 0x6e, 0xcd, 0x31, 0x5f,
	0xe9, 0xc1, 0x7f, 0x5e, 0x84, 0xb5, 0x85, 0x19, 0xae, 0xb5, 0xdb, 0x7b, 0xd0, 0xd0, 0x87, 0x17,
	0xfa, 0x83, 0xbc, 0xbe, 0x61, 0xcf, 0x5c, 0x03, 0xa5, 0x3b, 0x60, 0x31, 0x9a, 0x50, 0x16, 0xc4,
	0xfe, 0xdc, 0xed, 0xad, 0xa1, 0xa0, 0x46, 0xd1, 0x1f, 0xc2, 0xba, 0x97, 0x4c, 0x67, 0xa7, 0x79,
	0xfe, 0x32, 0x4e, 0xbc, 0x64, 0x6a, 0xce, 0x70, 0xc3, 0xf1, 0x18, 0x2c, 0xc9, 0x61, 0x56, 0xc0,
	0x5c, 0x41, 0x75, 0x29, 0xdc, 0xf4, 0x92, 0xa9, 0xde, 0x89, 0xed, 0x0a, 0x2a, 0x93, 0xd4, 0x64,
	0x2a, 0xe8, 0x9b, 0x94, 0x36, 0xbd, 0x5c, 0x2b, 0x9b, 0xaf, 0x23, 0x56, 0x73, 0xbc, 0xd0, 0x38,
	0x99, 0x43, 0x87, 0x61, 0xec, 0x9d, 0xe6, 0x67, 0x50, 0x1e, 0x60, 0x21, 0x26, 0x3b, 0xc7, 0x0e,
	0x6c, 0xa4, 0x89, 0x30, 0x54, 0x4d, 0xe1, 0x59, 0x63, 0xbb, 0x62, 0xdf, 0x36, 0x79, 0x30, 0xc4,
	0x36, 0xb0, 0xea, 0x61, 0x3f, 0x81, 0x35, 0xcd, 0x13, 0x06, 0xd1, 0xa9, 0x0a, 0x2d, 0x9d, 0x06,
	0x74, 0xf0, 0x76, 0x83, 0xe8, 0x14, 0x63, 0xab, 0xfd, 0x37, 0x4b, 0x60, 0xcd, 0x9b, 0xf0, 0xff,
	0x22, 0xa8, 0xde, 0x72, 0xf5, 0xf8, 0x1f, 0xbd, 0x53, 0xa8, 0xb3, 0xe4, 0x75, 0xa9, 0x52, 0xb6,
	0x96, 0x5f, 0x97, 0x2a, 0x2b, 0x56, 0xc5, 0xce, 0x5d, 0xac, 0xec, 0x59, 0x7c, 0xdb, 0x73, 0xd1,
	0xdc, 0xfe, 0x8f, 0xa2, 0x69, 0xd9, 0xb0, 0xb7, 0x04, 0x5c, 0xb6, 0xd9, 0xb2, 0x94, 0x6f, 0xb6,
	0x60, 0x96, 0x96, 0xd5, 0x87, 0x33, 0xd7, 0x8e, 0x69, 0x20, 0x34, 0x75, 0x95, 0x5f, 0x81, 0x65,
	0xff, 0x82, 0xca, 0x12, 0xa2, 0x84, 0xf5, 0x7d, 0xc3, 0x34, 0xf1, 0x11, 0x68, 0x1e, 0x60, 0x14,
	0x89, 0x8c, 0x1a, 0xe3, 0x29, 0x8a, 0x47, 0x5f, 0x5b, 0xb4, 0x87, 0x28, 0xa2, 0x99, 0x6b, 0x4c,
	0x82, 0xc8, 0x94, 0x54, 0xd5, 0xac, 0x6b, 0x1c, 0x06, 0x91, 0xae, 0xa6, 0xb6, 0x41, 0x7b, 0x97,
	0x33, 0x0c, 0xe3, 0x78, 0x62, 0xc4, 0x2a, 0x47, 0xd2, 0x62, 0x9e, 0x4b, 0x8c, 0x96, 0xfd, 0x0c,
	0xea, 0x39, 0xc2, 0x5a, 0xee, 0x0a, 0x9d, 0xa1, 0x34, 0xbd, 0xf7, 0x61, 0x86, 0xf9, 0x63, 0x00,
	0x19, 0x07, 0xba, 0xc7, 0x52, 0xcf, 0xf5, 0x03, 0x06, 0xf1, 0x29, 0x8d, 0x54, 0x49, 0xaf, 0x9f,
	0x1e, 0xaa, 0x92, 0x56, 0x35, 0x5f, 0xbe, 0x0f, 0xcb, 0xfa, 0x45, 0xa0, 0x91, 0x3b, 0xd4, 0xec,
	0xc4, 0x33, 0x35, 0x56, 0xae, 0x62, 0xd2, 0xd4, 0x92, 0xcf, 0x0b, 0x03, 0x1a, 0x09, 0xdd, 0x72,
	0x7e, 0x2b, 0x9f, 0xa2, 0x6e, 0x7f, 0x55, 0x80, 0x8d, 0x4b, 0x2b, 0x32, 0xf2, 0x11, 0x6c, 0xe9,
	0x02, 0x12, 0xbd, 0xc8, 0x49, 0x28, 0x93, 0x5a, 0x9e, 0x0a, 0xf3, 0x34, 0xb2, 0xae, 0xd0, 0xe8,
	0xa9, 0x3d, 0xca, 0x0e, 0x11, 0x47, 0xbe, 0x03, 0xeb, 0xd2, 0xb5, 0x17, 0x78, 0x54, 0x67, 0x6b,
	0x6d, 0xe2, 0xbe, 0x99, 0x63, 0x78, 0x1f, 0x9a, 0x89, 0x2b, 0xc6, 0x4e, 0xca, 0x65, 0xda, 0x5b,
	0x12, 0x7a, 0xa8, 0xc9, 0xc9, 0x23, 0xa8, 0x87, 0xc1, 0x09, 0x95, 0x21, 0x24, 0x9d, 0x57, 0x87,
	0x5c, 0xcd, 0xc0, 0xfa, 0xd4, 0x6b, 0x7f, 0x09, 0x6b, 0x0b, 0xaa, 0x95, 0x6e, 0xcb, 0x85, 0x54,
	0xef, 0xc8, 0x5c, 0xde, 0xd2, 0xb1, 0xbc, 0x4f, 0xe1, 0x61, 0x25, 0x97, 0x56, 0xb2, 0xf1, 0x5b,
	0x96, 0x09, 0xc3, 0x29, 0xe3, 0x6a, 0x11, 0x25, 0x5b, 0x0d, 0xda, 0x3b, 0xb0, 0xac, 0x0d, 0xbb,
	0x78, 0x0f, 0xdc, 0x84, 0x65, 0xbc, 0xfa, 0x99, 0xa6, 0xae, 0x1e, 0xb5, 0xff, 0xb8, 0x0c, 0x15,
	0xf3, 0xa6, 0x97, 0x79, 0x2e, 0x2a, 0xe4, 0x9e, 0x8b, 0xee, 0x41, 0x15, 0x1b, 0xc2, 0x89, 0x3c,
	0xd3, 0xd4, 0xed, 0x6f, 0x06, 0x20, 0x77, 0xa0, 0x42, 0xa3, 0x33, 0xd5, 0xb1, 0x54, 0xd7, 0xfd,
	0x15, 0x1a, 0x9d, 0x61, 0xb7, 0x72, 0x13, 0x96, 0x19, 0x1d, 0x99, 0x07, 0xb1, 0xaa, 0xad, 0x47,
	0xaa, 0x15, 0xc0, 0x85, 0x1b, 0x79, 0x54, 0x57, 0x3a, 0xe9, 0x18, 0xef, 0x8f, 0xb2, 0x3c, 0x5a,
	0xd6, 0xf7, 0x47, 0x59, 0x16, 0x7d, 0x00, 0x4d, 0x2f, 0x8e, 0x84, 0x1b, 0x44, 0x54, 0xb7, 0x46,
	0xd5, 0x15, 0xbf, 0x91, 0x42, 0x8f, 0xf4, 0x35, 0xd3, 0xbc, 0xb8, 0xa8, 0x72, 0x26, 0x7d, 0x71,
	0xc9, 0xbe, 0xeb, 0x56, 0xaf, 0x7f, 0xd7, 0x85, 0x85, 0x77, 0x5d, 0x0b, 0x8a, 0x6e, 0x92, 0xe0,
	0xe5, 0xa9, 0x6a, 0xcb, 0x4f, 0xb9, 0x2f, 0xed, 0xff, 0x75, 0xb5, 0x2f, 0xed, 0xdf, 0x77, 0xa0,
	0xc2, 0xa9, 0x96, 0xd3, 0x50, 0x2b, 0xe0, 0x54, 0x09, 0x79, 0x17, 0xe0, 0x84, 0xb9, 0x13, 0x8a,
	0x9d, 0x3b, 0x74, 0xff, 0xaa, 0x5d, 0x45, 0xc8, 0x9e, 0xdc, 0xe1, 0x23, 0xa8, 0x4b, 0x19, 0x81,
	0x47, 0x15, 0xf7, 0xaa, 0x6a, 0xfd, 0x6a, 0x18, 0x4a, 0xc8, 0x3d, 0x36, 0x59, 0x73, 0x8f, 0x4d,
	0x5b, 0xb0, 0xe2, 0x4d, 0xfc, 0xa1, 0x44, 0xad, 0xa9, 0x25, 0xc9, 0xe1, 0x81, 0x8f, 0xfd, 0x70,
	0xb4, 0xa2, 0x2a, 0xf3, 0x88, 0x4a, 0x02, 0x0a, 0x64, 0xfa, 0xd3, 0xa1, 0x1b, 0x8d, 0xa6, 0xee,
	0x88, 0xb6, 0xd6, 0x95, 0x54, 0x33, 0xc6, 0xfd, 0xf8, 0xa7, 0x6a, 0x45, 0x1b, 0x7a, 0x3f, 0xfe,
	0x29, 0xae, 0x86, 0x40, 0xc9, 0x0b, 0xc4, 0x45, 0x6b, 0x53, 0x99, 0x49, 0x7e, 0xcb, 0x3d, 0xba,
	0xbe, 0x3c, 0xe3, 0xf0, 0xd1, 0x7d, 0xeb, 0x61, 0xe1, 0x71, 0xc3, 0xae, 0x22, 0xa4, 0x17, 0x33,
	0xa1, 0x1e, 0x14, 0x43, 0xea, 0x72, 0xea, 0x18, 0x33, 0xb5, 0xcc, 0x83, 0x22, 0x82, 0xbf, 0xd0,
	0x4f, 0x9e, 0xbf, 0xb7, 0x04, 0x75, 0xd5, 0xd9, 0xeb, 0x7b, 0x63, 0x3a, 0x71, 0x6f, 0xf8, 0x74,
	0xa1, 0x3a, 0xba, 0xb9, 0xd7, 0x79, 0x05, 0x9a, 0x23, 0x40, 0x45, 0x14, 0xb3, 0x04, 0xa8, 0x88,
	0x87, 0x50, 0x73, 0x47, 0x23, 0x46, 0x47, 0x58, 0x99, 0x68, 0x8f, 0xcd, 0x82, 0x70, 0x19, 0x4a,
	0x84, 0x1b, 0x06, 0x2e, 0xd7, 0xae, 0xab, 0xc5, 0xee, 0x4a, 0x50, 0x66, 0x16, 0x9f, 0x72, 0x4f,
	0x3b, 0xb1, 0x9e, 0x65, 0x9f, 0x72, 0x4f, 0xba, 0x0e, 0xf6, 0x73, 0x65, 0x8d, 0x8a, 0x81, 0xa8,
	0x46, 0x32, 0xa4, 0xa7, 0x5c, 0xda, 0x40, 0x79, 0xae, 0x1a, 0xb4, 0x3f, 0x83, 0x6a, 0x37, 0x1e,
	0x69, 0x2d, 0xdc, 0x81, 0x8a, 0xac, 0xda, 0x33, 0x1a, 0x58, 0x09, 0xe3, 0x91, 0x09, 0xb4, 0xcb,
	0xa4, 0xb6, 0x3f, 0x80, 0x1a, 0x96, 0x1c, 0x5a, 0xc2, 0x55, 0x64, 0xaf, 0xa1, 0xa1, 0xeb, 0x91,
	0x99, 0xc2, 0xb3, 0xd5, 0xa0, 0x51, 0x78, 0xa6, 0x18, 0xbc, 0x52, 0xd6, 0xbf, 0x2f, 0xc1, 0x66,
	0xda, 0x54, 0x52, 0xe2, 0xcc, 0xdf, 0x15, 0xd9, 0xdf, 0x0a, 0x0a, 0x37, 0xfb, 0xad, 0xe0, 0x3d,
	0x68, 0x70, 0xca, 0x02, 0x37, 0x74, 0xa2, 0xe9, 0x64, 0x48, 0x99, 0x3e, 0x06, 0xeb, 0x0a, 0x78,
	0x84, 0x30, 0xf2, 0x1b, 0xe6, 0x0d, 0xd9, 0xe1, 0x38, 0x9f, 0x2a, 0x5e, 0x67, 0x97, 0xbd, 0xac,
	0x2f, 0xe5, 0x9f, 0x90, 0x15, 0x0c, 0x9b, 0xf2, 0xea, 0x76, 0x66, 0x04, 0x94, 0x72, 0x79, 0x34,
	0xa3, 0xc3, 0xdc, 0x0b, 0xb2, 0x61, 0xff, 0x18, 0x5f, 0x90, 0x53, 0xe6, 0x32, 0x32, 0x5b, 0xb3,
	0xab, 0x66, 0x8e, 0x15, 0x42, 0x03, 0xc0, 0x4e, 0xba, 0xd1, 0xb3, 0x61, 0x5e, 0xce, 0x75, 0xd2,
	0x73, 0x66, 0x99, 0x7b, 0x08, 0xd6, 0x42, 0xda, 0x9f, 0xc3, 0xd6, 0x82, 0xc2, 0x7f, 0x96, 0xdf,
	0x04, 0xda, 0x1c, 0x6a, 0xd9, 0x9a, 0x62, 0x31, 0x7b, 0xdc, 0x81, 0xca, 0x30, 0xd0, 0xd7, 0x26,
	0x95, 0x22, 0x57, 0x86, 0x81, 0xba, 0x33, 0x3d, 0x80, 0xda, 0xd8, 0xe5, 0x63, 0x63, 0x1e, 0x95,
	0x15, 0x41, 0x82, 0xb4, 0x71, 0x36, 0x61, 0x79, 0x18, 0x88, 0x89, 0x9b, 0xa0, 0x4e, 0x8b, 0xb6,
	0x1e, 0xc9, 0x44, 0xb8, 0x90, 0xf6, 0x73, 0xf5, 0x5b, 0x61, 0xae, 0x7e, 0x7b, 0x0c, 0x45, 0x96,
	0x78, 0x98, 0xbf, 0x66, 0xca, 0xb5, 0x13, 0x2f, 0x57, 0x31, 0x48, 0x92, 0xf6, 0x33, 0xa8, 0xa6,
	0xf0, 0x4b, 0xfb, 0x91, 0xd7, 0x94, 0x89, 0x4f, 0xfe, 0xb4, 0x00, 0x8d, 0xdc, 0xaf, 0x22, 0xe4,
	0x2e, 0x6c, 0x0e, 0x3a, 0xdd, 0xce, 0x61, 0x67, 0x60, 0x7f, 0xe9, 0xec, 0xef, 0x0e, 0x76, 0x9d,
	0x83, 0xa3, 0x2f, 0x76, 0xbb, 0x07, 0xfb, 0xd6, 0xad, 0x4b, 0x70, 0xf2, 0xf3, 0x60, 0xaf, 0x6f,
	0x15, 0xc8, 0x16, 0xdc, 0x9e, 0xc3, 0x75, 0x8f, 0x5f, 0xf6, 0xad, 0x25, 0x72, 0x07, 0x36, 0xe6,
	0x10, 0x03, 0x7b, 0x77, 0xaf, 0xd3, 0xb7, 0x8a, 0xe4, 0x1d, 0xd8, 0x9a, 0x43, 0xf5, 0xec, 0xe3,
	0x17, 0x07, 0xdd, 0x4e, 0xdf, 0x2a, 0x3d, 0xf9, 0xab, 0x02, 0xd4, 0xb3, 0x7f, 0xa2, 0x48, 0x41,
	0x86, 0x66, 0x70, 0xbc, 0x77, 0xdc, 0xcd, 0x2c, 0x6c, 0x13, 0x48, 0x1e, 0x75, 0x3c, 0xe8, 0xf6,
	0xac, 0x02, 0xb9, 0x07, 0xad, 0x3c, 0xbc, 0x67, 0x1f, 0x1f, 0x76, 0x06, 0xaf, 0x3a, 0x3f, 0x90,
	0x2b, 0x6b, 0xc1, 0x7a, 0x1e, 0xfb, 0x7a, 0xb7, 0xf3, 0xb2, 0x63, 0x5b, 0xc5, 0x45, 0x79, 0x87,
	0x1f, 0x7e, 0xf8, 0xb1, 0x55, 0x22, 0x1b, 0xb0, 0x36, 0x3f, 0x4f, 0xcf, 0x2a, 0x3f, 0xf9, 0x9d,
	0x02, 0x58, 0xf3, 0xbf, 0xbd, 0x90, 0x77, 0xe1, 0x8e, 0xd9, 0xed, 0x51, 0xff, 0xf0, 0xa0, 0xdf,
	0x3f, 0x38, 0x3e, 0xca, 0xeb, 0x72, 0x11, 0xfd, 0x6a, 0x30, 0x90, 0xcb, 0xbe, 0x14, 0x37, 0xb2,
	0x7b, 0x7b, 0xd6, 0xd2, 0xe5, 0x38, 0x21, 0x71, 0xc5, 0x27, 0x09, 0xac, 0x2d, 0x3c, 0xcf, 0x92,
	0x07, 0xf0, 0x8e, 0xb6, 0x92, 0xd3, 0xdf, 0x3d, 0xec, 0x75, 0x3b, 0xce, 0xe0, 0xcb, 0x5e, 0x27,
	0xb3, 0x92, 0x7b, 0xd0, 0xba, 0x8c, 0xc0, 0xde, 0x3d, 0xda, 0x57, 0x2a, 0xbc, 0x14, 0x7b, 0xfc,
	0xc3, 0xbe, 0xb5, 0xf4, 0xe4, 0xcf, 0x0a, 0x50, 0xcb, 0xfc, 0x7c, 0x21, 0x55, 0xba, 0xbb, 0xb7,
	0xd7, 0xe9, 0xf7, 0x9d, 0xde, 0xf1, 0xc1, 0xd1, 0x20, 0xbf, 0xdf, 0x1c, 0xa6, 0xff, 0xd2, 0xe9,
	0xfd, 0xe0, 0x79, 0xf7, 0x60, 0xcf, 0x2a, 0x48, 0x3f, 0x58, 0xc0, 0xd9, 0x07, 0x5f, 0xec, 0x0e,
	0x3a, 0x6a, 0xc3, 0x39, 0xe4, 0xde, 0x91, 0x61, 0x2c, 0x2e, 0x30, 0x4a, 0x9c, 0x66, 0x2c, 0x3d,
	0xff, 0xf4, 0xab, 0xaf, 0xef, 0x17, 0x7e, 0xf2, 0xf5, 0xfd, 0xc2, 0x3f, 0x7f, 0x7d, 0xbf, 0xf0,
	0x47, 0xdf, 0xdc, 0xbf, 0xf5, 0x93, 0x6f, 0xee, 0xdf, 0xfa, 0xe9, 0x37, 0xf7, 0x6f, 0xc1, 0x1d,
	0x2f, 0x9e, 0x6c, 0x0b, 0x1a, 0x79, 0x34, 0x12, 0xdb, 0x23, 0x37, 0x0c, 0x42, 0xaa, 0xff, 0x23,
	0xfc, 0x2d, 0xf5, 0x93, 0xe1, 0x70, 0x19, 0x47, 0xbf, 0xfa, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xd0, 0x18, 0x95, 0x53, 0x7f, 0x28, 0x00, 0x00,
}

func (m *Collector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Collector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Collector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DirectIpPort) > 0 {
		for iNdEx := len(m.DirectIpPort) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DirectIpPort[iNdEx])
			copy(dAtA[i:], m.DirectIpPort[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.DirectIpPort[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Version != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if m.DataTransmission != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.DataTransmission))
		i--
		dAtA[i] = 0x20
	}
	if m.DataProtocol != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.DataProtocol))
		i--
		dAtA[i] = 0x18
	}
	if m.TelemetryData != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TelemetryData))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOcp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.Profiles.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Set) > 0 {
		i -= len(m.Set)
		copy(dAtA[i:], m.Set)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Set)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Env) > 0 {
		i -= len(m.Env)
		copy(dAtA[i:], m.Env)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Env)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.Logs.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Traces.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Metrics.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollectorProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorProtocol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollectorProtocol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if m.DataTransmission != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.DataTransmission))
		i--
		dAtA[i] = 0x20
	}
	if m.DataProtocol != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.DataProtocol))
		i--
		dAtA[i] = 0x18
	}
	if m.TelemetryData != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TelemetryData))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.OpentelemetryPush.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.PrometheusPush.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if m.AccessPoint != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.AccessPoint))
		i--
		dAtA[i] = 0x68
	}
	{
		size, err := m.ProfilesConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.Version != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x58
	}
	if len(m.TenantId) > 0 {
		i -= len(m.TenantId)
		copy(dAtA[i:], m.TenantId)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.TenantId)))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.LogsConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.TracesConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.MetricsConfig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.SelfMonitor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.RegisterServer) > 0 {
		i -= len(m.RegisterServer)
		copy(dAtA[i:], m.RegisterServer)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.RegisterServer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ConfigServer) > 0 {
		i -= len(m.ConfigServer)
		copy(dAtA[i:], m.ConfigServer)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ConfigServer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SelfMonitor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelfMonitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SelfMonitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.ReportSeconds))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Collector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableSse {
		i--
		if m.EnableSse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Exporter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Processor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LabelIgnore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelIgnore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelIgnore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LabelNames) > 0 {
		for iNdEx := len(m.LabelNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LabelNames[iNdEx])
			copy(dAtA[i:], m.LabelNames[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.LabelNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MonitorName) > 0 {
		i -= len(m.MonitorName)
		copy(dAtA[i:], m.MonitorName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MonitorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecondGranularity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondGranularity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondGranularity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TtlSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TtlSeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.WindowSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.WindowSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.EndSecond != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.EndSecond))
		i--
		dAtA[i] = 0x18
	}
	if m.BeginSecond != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BeginSecond))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MonitorName) > 0 {
		i -= len(m.MonitorName)
		copy(dAtA[i:], m.MonitorName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MonitorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SampleMonitor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SampleMonitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SampleMonitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fraction != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fraction))))
		i--
		dAtA[i] = 0x19
	}
	if m.SampleType != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.SampleType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MonitorName) > 0 {
		i -= len(m.MonitorName)
		copy(dAtA[i:], m.MonitorName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MonitorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RPCHasTwoIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPCHasTwoIP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RPCHasTwoIP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndSecond != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.EndSecond))
		i--
		dAtA[i] = 0x18
	}
	if m.BeginSecond != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BeginSecond))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MonitorName) > 0 {
		i -= len(m.MonitorName)
		copy(dAtA[i:], m.MonitorName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MonitorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsProcessor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsProcessor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsProcessor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RpcHasTwoIps) > 0 {
		for iNdEx := len(m.RpcHasTwoIps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RpcHasTwoIps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.SampleMonitors) > 0 {
		for iNdEx := len(m.SampleMonitors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SampleMonitors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.SecondGranularitys) > 0 {
		for iNdEx := len(m.SecondGranularitys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SecondGranularitys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.RetCodeAsException {
		i--
		if m.RetCodeAsException {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.LabelIgnores) > 0 {
		for iNdEx := len(m.LabelIgnores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LabelIgnores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.HistogramBuckets) > 0 {
		for iNdEx := len(m.HistogramBuckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistogramBuckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ProcessMetricsSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.ProcessMetricsSeconds))
		i--
		dAtA[i] = 0x38
	}
	if m.EnableProcessMetrics {
		i--
		if m.EnableProcessMetrics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.PointLimit != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PointLimit))
		i--
		dAtA[i] = 0x28
	}
	if m.ExpiresSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.ExpiresSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.ClearSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.ClearSeconds))
		i--
		dAtA[i] = 0x18
	}
	if m.WindowSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.WindowSeconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsExporter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsExporter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsExporter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExportToFile {
		i--
		if m.ExportToFile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxRetryCount != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.MaxRetryCount))
		i--
		dAtA[i] = 0x40
	}
	if m.WindowSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.WindowSeconds))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeoutMs != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TimeoutMs))
		i--
		dAtA[i] = 0x30
	}
	if m.PageSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x28
	}
	if m.BufferSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x20
	}
	if m.ThreadCount != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.ThreadCount))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Collector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrometheusPushConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrometheusPushConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrometheusPushConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HttpHeaders) > 0 {
		for k := range m.HttpHeaders {
			v := m.HttpHeaders[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintOcp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOcp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOcp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Grouping) > 0 {
		for k := range m.Grouping {
			v := m.Grouping[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintOcp(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintOcp(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintOcp(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x32
	}
	if m.UseBasicAuth {
		i--
		if m.UseBasicAuth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Interval != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Job) > 0 {
		i -= len(m.Job)
		copy(dAtA[i:], m.Job)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Job)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpenTelemetryPushConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenTelemetryPushConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenTelemetryPushConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HistogramBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistogramBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistogramBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			f18 := math.Float64bits(float64(m.Buckets[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f18))
		}
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Buckets)*8))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracesConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracesConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableSse {
		i--
		if m.EnableSse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.Exporter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Processor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TracesProcessor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracesProcessor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracesProcessor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisableStreamTraceBody {
		i--
		if m.DisableStreamTraceBody {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.EnableProfile {
		i--
		if m.EnableProfile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.WorkflowSampler.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.DisableParentSampling {
		i--
		if m.DisableParentSampling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.DeferredSampleSlowDurationMs != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.DeferredSampleSlowDurationMs))
		i--
		dAtA[i] = 0x38
	}
	if m.DeferredSampleError {
		i--
		if m.DeferredSampleError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.EnableDeferredSample {
		i--
		if m.EnableDeferredSample {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.DisableTraceBody {
		i--
		if m.DisableTraceBody {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Sampler.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TracesExporter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TracesExporter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TracesExporter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExportToFile {
		i--
		if m.ExportToFile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.PacketSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PacketSize))
		i--
		dAtA[i] = 0x40
	}
	if m.WindowSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.WindowSeconds))
		i--
		dAtA[i] = 0x38
	}
	if m.PageSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x28
	}
	if m.BufferSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Collector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Exporter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Processor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogsProcessor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsProcessor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsProcessor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogTracedType) > 0 {
		i -= len(m.LogTracedType)
		copy(dAtA[i:], m.LogTracedType)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.LogTracedType)))
		i--
		dAtA[i] = 0x42
	}
	if m.MustLogTraced {
		i--
		if m.MustLogTraced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.EnableRecovery {
		i--
		if m.EnableRecovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TraceLogMode != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TraceLogMode))
		i--
		dAtA[i] = 0x20
	}
	if m.OnlyTraceLog {
		i--
		if m.OnlyTraceLog {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogsExporter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsExporter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogsExporter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExportToFile {
		i--
		if m.ExportToFile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.PacketSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PacketSize))
		i--
		dAtA[i] = 0x40
	}
	if m.WindowSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.WindowSeconds))
		i--
		dAtA[i] = 0x38
	}
	if m.PageSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x28
	}
	if m.BufferSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Collector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProfilesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilesConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfilesConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Exporter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Processor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProfilesProcessor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilesProcessor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfilesProcessor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableLinkTrace {
		i--
		if m.EnableLinkTrace {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.EnableDeltaProfiles {
		i--
		if m.EnableDeltaProfiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.BlockProfileRate != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BlockProfileRate))
		i--
		dAtA[i] = 0x40
	}
	if m.MutexProfileFraction != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.MutexProfileFraction))
		i--
		dAtA[i] = 0x38
	}
	if m.CpuProfileRate != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.CpuProfileRate))
		i--
		dAtA[i] = 0x30
	}
	if m.CpuDurationSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.CpuDurationSeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.PeriodSeconds != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PeriodSeconds))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ProfileTypes) > 0 {
		for iNdEx := len(m.ProfileTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProfileTypes[iNdEx])
			copy(dAtA[i:], m.ProfileTypes[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.ProfileTypes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProfilesExporter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilesExporter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfilesExporter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExportToFile {
		i--
		if m.ExportToFile {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxRetryCount != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.MaxRetryCount))
		i--
		dAtA[i] = 0x40
	}
	if m.TimeoutMs != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TimeoutMs))
		i--
		dAtA[i] = 0x30
	}
	if m.BufferSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Collector.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SamplerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SamplerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SamplerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Client.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size, err := m.Server.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.RateLimit) > 0 {
		for iNdEx := len(m.RateLimit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RateLimit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.BloomDyeing) > 0 {
		for iNdEx := len(m.BloomDyeing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BloomDyeing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.EnableBloomDyeing {
		i--
		if m.EnableBloomDyeing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.EnableMinSample {
		i--
		if m.EnableMinSample {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.EnableDyeing {
		i--
		if m.EnableDyeing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Dyeing) > 0 {
		for iNdEx := len(m.Dyeing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dyeing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ErrorFraction != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ErrorFraction))))
		i--
		dAtA[i] = 0x19
	}
	if m.Fraction != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fraction))))
		i--
		dAtA[i] = 0x11
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowSamplerConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowSamplerConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowSamplerConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LifetimeSec != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.LifetimeSec))
		i--
		dAtA[i] = 0x20
	}
	if m.PathMaxCount != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.PathMaxCount))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxCountPerMinute != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.MaxCountPerMinute))
		i--
		dAtA[i] = 0x10
	}
	if m.SampleCountPerMinute != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.SampleCountPerMinute))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TokenBucketConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenBucketConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenBucketConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Burst != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Burst))
		i--
		dAtA[i] = 0x18
	}
	if m.Rate != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Strategy) > 0 {
		i -= len(m.Strategy)
		copy(dAtA[i:], m.Strategy)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Strategy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Dyeing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dyeing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dyeing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReleaseVersion) > 0 {
		i -= len(m.ReleaseVersion)
		copy(dAtA[i:], m.ReleaseVersion)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ReleaseVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.AdminPort != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.AdminPort))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.SdkName) > 0 {
		i -= len(m.SdkName)
		copy(dAtA[i:], m.SdkName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.SdkName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.TargetType != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.TargetType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.CmdbId) > 0 {
		i -= len(m.CmdbId)
		copy(dAtA[i:], m.CmdbId)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.CmdbId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TenantId) > 0 {
		i -= len(m.TenantId)
		copy(dAtA[i:], m.TenantId)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.TenantId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.FrameCode) > 0 {
		i -= len(m.FrameCode)
		copy(dAtA[i:], m.FrameCode)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.FrameCode)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.SetName) > 0 {
		i -= len(m.SetName)
		copy(dAtA[i:], m.SetName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.SetName)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.App) > 0 {
		i -= len(m.App)
		copy(dAtA[i:], m.App)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.App)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ContainerName) > 0 {
		i -= len(m.ContainerName)
		copy(dAtA[i:], m.ContainerName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ContainerName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Instance) > 0 {
		i -= len(m.Instance)
		copy(dAtA[i:], m.Instance)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Instance)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EnvName) > 0 {
		i -= len(m.EnvName)
		copy(dAtA[i:], m.EnvName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.EnvName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Usage) > 0 {
		i -= len(m.Usage)
		copy(dAtA[i:], m.Usage)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Usage)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Labels[iNdEx])
			copy(dAtA[i:], m.Labels[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.Labels[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.MetricDesc) > 0 {
		i -= len(m.MetricDesc)
		copy(dAtA[i:], m.MetricDesc)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MetricDesc)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MetricAlias) > 0 {
		i -= len(m.MetricAlias)
		copy(dAtA[i:], m.MetricAlias)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MetricAlias)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Aggregation) > 0 {
		i -= len(m.Aggregation)
		copy(dAtA[i:], m.Aggregation)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Aggregation)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MetricType) > 0 {
		i -= len(m.MetricType)
		copy(dAtA[i:], m.MetricType)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MetricType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MonitorName) > 0 {
		i -= len(m.MonitorName)
		copy(dAtA[i:], m.MonitorName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.MonitorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Labels[iNdEx])
			copy(dAtA[i:], m.Labels[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.Labels[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LogName) > 0 {
		i -= len(m.LogName)
		copy(dAtA[i:], m.LogName)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.LogName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraceSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraceSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Labels[iNdEx])
			copy(dAtA[i:], m.Labels[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.Labels[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProfileSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfileSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Labels[iNdEx])
			copy(dAtA[i:], m.Labels[iNdEx])
			i = encodeVarintOcp(dAtA, i, uint64(len(m.Labels[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ProfileType) > 0 {
		i -= len(m.ProfileType)
		copy(dAtA[i:], m.ProfileType)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.ProfileType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelemetrySchemaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetrySchemaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetrySchemaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProfileSchemas) > 0 {
		for iNdEx := len(m.ProfileSchemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProfileSchemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LogSchemas) > 0 {
		for iNdEx := len(m.LogSchemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogSchemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TraceSchemas) > 0 {
		for iNdEx := len(m.TraceSchemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TraceSchemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MetricSchemas) > 0 {
		for iNdEx := len(m.MetricSchemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetricSchemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SerialNumber != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.SerialNumber))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TelemetrySchemaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetrySchemaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetrySchemaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BloomDyeing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BloomDyeing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BloomDyeing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Bitmap) > 0 {
		dAtA34 := make([]byte, len(m.Bitmap)*10)
		var j33 int
		for _, num1 := range m.Bitmap {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintOcp(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x22
	}
	if m.HashNumber != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.HashNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.BitSize != 0 {
		i = encodeVarintOcp(dAtA, i, uint64(m.BitSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RpcSamplingConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcSamplingConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcSamplingConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rpc) > 0 {
		for iNdEx := len(m.Rpc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rpc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOcp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Fraction != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fraction))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *RpcConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fraction != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fraction))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOcp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOcp(dAtA []byte, offset int, v uint64) int {
	offset -= sovOcp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Collector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.TelemetryData != 0 {
		n += 1 + sovOcp(uint64(m.TelemetryData))
	}
	if m.DataProtocol != 0 {
		n += 1 + sovOcp(uint64(m.DataProtocol))
	}
	if m.DataTransmission != 0 {
		n += 1 + sovOcp(uint64(m.DataTransmission))
	}
	if m.Version != 0 {
		n += 1 + sovOcp(uint64(m.Version))
	}
	if len(m.DirectIpPort) > 0 {
		for _, s := range m.DirectIpPort {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *GetConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Metrics.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Traces.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Logs.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Set)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Resource.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Profiles.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovOcp(uint64(l))
	}
	return n
}

func (m *CollectorProtocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TelemetryData != 0 {
		n += 1 + sovOcp(uint64(m.TelemetryData))
	}
	if m.DataProtocol != 0 {
		n += 1 + sovOcp(uint64(m.DataProtocol))
	}
	if m.DataTransmission != 0 {
		n += 1 + sovOcp(uint64(m.DataTransmission))
	}
	if m.Version != 0 {
		n += 1 + sovOcp(uint64(m.Version))
	}
	return n
}

func (m *GetConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovOcp(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.ConfigServer)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.RegisterServer)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.SelfMonitor.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.MetricsConfig.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.TracesConfig.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.LogsConfig.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = len(m.TenantId)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovOcp(uint64(m.Version))
	}
	l = m.ProfilesConfig.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.AccessPoint != 0 {
		n += 1 + sovOcp(uint64(m.AccessPoint))
	}
	l = m.PrometheusPush.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.OpentelemetryPush.Size()
	n += 1 + l + sovOcp(uint64(l))
	return n
}

func (m *SelfMonitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Collector.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.ReportSeconds != 0 {
		n += 1 + sovOcp(uint64(m.ReportSeconds))
	}
	return n
}

func (m *MetricsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = m.Processor.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Exporter.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.EnableSse {
		n += 2
	}
	return n
}

func (m *LabelIgnore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MonitorName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.LabelNames) > 0 {
		for _, s := range m.LabelNames {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *SecondGranularity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MonitorName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.BeginSecond != 0 {
		n += 1 + sovOcp(uint64(m.BeginSecond))
	}
	if m.EndSecond != 0 {
		n += 1 + sovOcp(uint64(m.EndSecond))
	}
	if m.WindowSeconds != 0 {
		n += 1 + sovOcp(uint64(m.WindowSeconds))
	}
	if m.TtlSeconds != 0 {
		n += 1 + sovOcp(uint64(m.TtlSeconds))
	}
	return n
}

func (m *SampleMonitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MonitorName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.SampleType != 0 {
		n += 1 + sovOcp(uint64(m.SampleType))
	}
	if m.Fraction != 0 {
		n += 9
	}
	return n
}

func (m *RPCHasTwoIP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MonitorName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.BeginSecond != 0 {
		n += 1 + sovOcp(uint64(m.BeginSecond))
	}
	if m.EndSecond != 0 {
		n += 1 + sovOcp(uint64(m.EndSecond))
	}
	return n
}

func (m *MetricsProcessor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.WindowSeconds != 0 {
		n += 1 + sovOcp(uint64(m.WindowSeconds))
	}
	if m.ClearSeconds != 0 {
		n += 1 + sovOcp(uint64(m.ClearSeconds))
	}
	if m.ExpiresSeconds != 0 {
		n += 1 + sovOcp(uint64(m.ExpiresSeconds))
	}
	if m.PointLimit != 0 {
		n += 1 + sovOcp(uint64(m.PointLimit))
	}
	if m.EnableProcessMetrics {
		n += 2
	}
	if m.ProcessMetricsSeconds != 0 {
		n += 1 + sovOcp(uint64(m.ProcessMetricsSeconds))
	}
	if len(m.HistogramBuckets) > 0 {
		for _, e := range m.HistogramBuckets {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.LabelIgnores) > 0 {
		for _, e := range m.LabelIgnores {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if m.RetCodeAsException {
		n += 2
	}
	if len(m.SecondGranularitys) > 0 {
		for _, e := range m.SecondGranularitys {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.SampleMonitors) > 0 {
		for _, e := range m.SampleMonitors {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.RpcHasTwoIps) > 0 {
		for _, e := range m.RpcHasTwoIps {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *MetricsExporter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Collector.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.ThreadCount != 0 {
		n += 1 + sovOcp(uint64(m.ThreadCount))
	}
	if m.BufferSize != 0 {
		n += 1 + sovOcp(uint64(m.BufferSize))
	}
	if m.PageSize != 0 {
		n += 1 + sovOcp(uint64(m.PageSize))
	}
	if m.TimeoutMs != 0 {
		n += 1 + sovOcp(uint64(m.TimeoutMs))
	}
	if m.WindowSeconds != 0 {
		n += 1 + sovOcp(uint64(m.WindowSeconds))
	}
	if m.MaxRetryCount != 0 {
		n += 1 + sovOcp(uint64(m.MaxRetryCount))
	}
	if m.ExportToFile {
		n += 2
	}
	return n
}

func (m *PrometheusPushConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Job)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovOcp(uint64(m.Interval))
	}
	if m.UseBasicAuth {
		n += 2
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.Grouping) > 0 {
		for k, v := range m.Grouping {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOcp(uint64(len(k))) + 1 + len(v) + sovOcp(uint64(len(v)))
			n += mapEntrySize + 1 + sovOcp(uint64(mapEntrySize))
		}
	}
	if len(m.HttpHeaders) > 0 {
		for k, v := range m.HttpHeaders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOcp(uint64(len(k))) + 1 + len(v) + sovOcp(uint64(len(v)))
			n += mapEntrySize + 1 + sovOcp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OpenTelemetryPushConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	return n
}

func (m *HistogramBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.Buckets) > 0 {
		n += 1 + sovOcp(uint64(len(m.Buckets)*8)) + len(m.Buckets)*8
	}
	return n
}

func (m *TracesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = m.Processor.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Exporter.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.EnableSse {
		n += 2
	}
	return n
}

func (m *TracesProcessor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Sampler.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.DisableTraceBody {
		n += 2
	}
	if m.EnableDeferredSample {
		n += 2
	}
	if m.DeferredSampleError {
		n += 2
	}
	if m.DeferredSampleSlowDurationMs != 0 {
		n += 1 + sovOcp(uint64(m.DeferredSampleSlowDurationMs))
	}
	if m.DisableParentSampling {
		n += 2
	}
	l = m.WorkflowSampler.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.EnableProfile {
		n += 2
	}
	if m.DisableStreamTraceBody {
		n += 2
	}
	return n
}

func (m *TracesExporter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Collector.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.BufferSize != 0 {
		n += 1 + sovOcp(uint64(m.BufferSize))
	}
	if m.PageSize != 0 {
		n += 1 + sovOcp(uint64(m.PageSize))
	}
	if m.WindowSeconds != 0 {
		n += 1 + sovOcp(uint64(m.WindowSeconds))
	}
	if m.PacketSize != 0 {
		n += 1 + sovOcp(uint64(m.PacketSize))
	}
	if m.ExportToFile {
		n += 2
	}
	return n
}

func (m *LogsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = m.Processor.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Exporter.Size()
	n += 1 + l + sovOcp(uint64(l))
	return n
}

func (m *LogsProcessor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.OnlyTraceLog {
		n += 2
	}
	if m.TraceLogMode != 0 {
		n += 1 + sovOcp(uint64(m.TraceLogMode))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.EnableRecovery {
		n += 2
	}
	if m.MustLogTraced {
		n += 2
	}
	l = len(m.LogTracedType)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	return n
}

func (m *LogsExporter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Collector.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.BufferSize != 0 {
		n += 1 + sovOcp(uint64(m.BufferSize))
	}
	if m.PageSize != 0 {
		n += 1 + sovOcp(uint64(m.PageSize))
	}
	if m.WindowSeconds != 0 {
		n += 1 + sovOcp(uint64(m.WindowSeconds))
	}
	if m.PacketSize != 0 {
		n += 1 + sovOcp(uint64(m.PacketSize))
	}
	if m.ExportToFile {
		n += 2
	}
	return n
}

func (m *ProfilesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	l = m.Processor.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Exporter.Size()
	n += 1 + l + sovOcp(uint64(l))
	return n
}

func (m *ProfilesProcessor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.ProfileTypes) > 0 {
		for _, s := range m.ProfileTypes {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if m.PeriodSeconds != 0 {
		n += 1 + sovOcp(uint64(m.PeriodSeconds))
	}
	if m.CpuDurationSeconds != 0 {
		n += 1 + sovOcp(uint64(m.CpuDurationSeconds))
	}
	if m.CpuProfileRate != 0 {
		n += 1 + sovOcp(uint64(m.CpuProfileRate))
	}
	if m.MutexProfileFraction != 0 {
		n += 1 + sovOcp(uint64(m.MutexProfileFraction))
	}
	if m.BlockProfileRate != 0 {
		n += 1 + sovOcp(uint64(m.BlockProfileRate))
	}
	if m.EnableDeltaProfiles {
		n += 2
	}
	if m.EnableLinkTrace {
		n += 2
	}
	return n
}

func (m *ProfilesExporter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = m.Collector.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.BufferSize != 0 {
		n += 1 + sovOcp(uint64(m.BufferSize))
	}
	if m.TimeoutMs != 0 {
		n += 1 + sovOcp(uint64(m.TimeoutMs))
	}
	if m.MaxRetryCount != 0 {
		n += 1 + sovOcp(uint64(m.MaxRetryCount))
	}
	if m.ExportToFile {
		n += 2
	}
	return n
}

func (m *SamplerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	if m.Fraction != 0 {
		n += 9
	}
	if m.ErrorFraction != 0 {
		n += 9
	}
	if len(m.Dyeing) > 0 {
		for _, e := range m.Dyeing {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if m.EnableDyeing {
		n += 2
	}
	if m.EnableMinSample {
		n += 2
	}
	if m.EnableBloomDyeing {
		n += 2
	}
	if len(m.BloomDyeing) > 0 {
		for _, e := range m.BloomDyeing {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.RateLimit) > 0 {
		for _, e := range m.RateLimit {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	l = m.Server.Size()
	n += 1 + l + sovOcp(uint64(l))
	l = m.Client.Size()
	n += 1 + l + sovOcp(uint64(l))
	return n
}

func (m *WorkflowSamplerConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SampleCountPerMinute != 0 {
		n += 1 + sovOcp(uint64(m.SampleCountPerMinute))
	}
	if m.MaxCountPerMinute != 0 {
		n += 1 + sovOcp(uint64(m.MaxCountPerMinute))
	}
	if m.PathMaxCount != 0 {
		n += 1 + sovOcp(uint64(m.PathMaxCount))
	}
	if m.LifetimeSec != 0 {
		n += 1 + sovOcp(uint64(m.LifetimeSec))
	}
	return n
}

func (m *TokenBucketConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Strategy)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.Rate != 0 {
		n += 1 + sovOcp(uint64(m.Rate))
	}
	if m.Burst != 0 {
		n += 1 + sovOcp(uint64(m.Burst))
	}
	return n
}

func (m *Dyeing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.EnvName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.ContainerName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.App)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.SetName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.FrameCode)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.TenantId)
	if l > 0 {
		n += 2 + l + sovOcp(uint64(l))
	}
	l = len(m.CmdbId)
	if l > 0 {
		n += 2 + l + sovOcp(uint64(l))
	}
	if m.TargetType != 0 {
		n += 2 + sovOcp(uint64(m.TargetType))
	}
	l = len(m.Language)
	if l > 0 {
		n += 2 + l + sovOcp(uint64(l))
	}
	l = len(m.SdkName)
	if l > 0 {
		n += 2 + l + sovOcp(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 2 + l + sovOcp(uint64(l))
	}
	if m.AdminPort != 0 {
		n += 2 + sovOcp(uint64(m.AdminPort))
	}
	l = len(m.ReleaseVersion)
	if l > 0 {
		n += 2 + l + sovOcp(uint64(l))
	}
	return n
}

func (m *MetricSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MonitorName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.MetricType)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.Aggregation)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.MetricAlias)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	l = len(m.MetricDesc)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	l = len(m.Usage)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	return n
}

func (m *LogSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LogName)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *TraceSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *ProfileSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProfileType)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *TelemetrySchemaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Resource.Size()
	n += 1 + l + sovOcp(uint64(l))
	if m.SerialNumber != 0 {
		n += 1 + sovOcp(uint64(m.SerialNumber))
	}
	if len(m.MetricSchemas) > 0 {
		for _, e := range m.MetricSchemas {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.TraceSchemas) > 0 {
		for _, e := range m.TraceSchemas {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.LogSchemas) > 0 {
		for _, e := range m.LogSchemas {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	if len(m.ProfileSchemas) > 0 {
		for _, e := range m.ProfileSchemas {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *TelemetrySchemaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovOcp(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	return n
}

func (m *BloomDyeing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.BitSize != 0 {
		n += 1 + sovOcp(uint64(m.BitSize))
	}
	if m.HashNumber != 0 {
		n += 1 + sovOcp(uint64(m.HashNumber))
	}
	if len(m.Bitmap) > 0 {
		l = 0
		for _, e := range m.Bitmap {
			l += sovOcp(uint64(e))
		}
		n += 1 + sovOcp(uint64(l)) + l
	}
	return n
}

func (m *RpcSamplingConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fraction != 0 {
		n += 9
	}
	if len(m.Rpc) > 0 {
		for _, e := range m.Rpc {
			l = e.Size()
			n += 1 + l + sovOcp(uint64(l))
		}
	}
	return n
}

func (m *RpcConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOcp(uint64(l))
	}
	if m.Fraction != 0 {
		n += 9
	}
	return n
}

func sovOcp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOcp(x uint64) (n int) {
	return sovOcp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Collector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Collector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Collector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelemetryData", wireType)
			}
			m.TelemetryData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TelemetryData |= TelemetryData(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProtocol", wireType)
			}
			m.DataProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProtocol |= DataProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTransmission", wireType)
			}
			m.DataTransmission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTransmission |= DataTransmission(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectIpPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectIpPort = append(m.DirectIpPort, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Traces.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Logs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Profiles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Local == nil {
				m.Local = &GetConfigResponse{}
			}
			if err := m.Local.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelemetryData", wireType)
			}
			m.TelemetryData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TelemetryData |= TelemetryData(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProtocol", wireType)
			}
			m.DataProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProtocol |= DataProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTransmission", wireType)
			}
			m.DataTransmission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTransmission |= DataTransmission(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfMonitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SelfMonitor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MetricsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TracesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TracesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LogsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfilesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProfilesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessPoint", wireType)
			}
			m.AccessPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessPoint |= AccessPoint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrometheusPush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrometheusPush.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpentelemetryPush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpentelemetryPush.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelfMonitor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SelfMonitor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SelfMonitor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSeconds", wireType)
			}
			m.ReportSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Processor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exporter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelIgnore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelIgnore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelIgnore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelNames = append(m.LabelNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondGranularity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondGranularity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondGranularity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginSecond", wireType)
			}
			m.BeginSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginSecond |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSecond", wireType)
			}
			m.EndSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndSecond |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSeconds", wireType)
			}
			m.WindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSeconds", wireType)
			}
			m.TtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SampleMonitor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SampleMonitor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SampleMonitor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleType", wireType)
			}
			m.SampleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleType |= MetricsSampleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fraction = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPCHasTwoIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCHasTwoIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCHasTwoIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginSecond", wireType)
			}
			m.BeginSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginSecond |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndSecond", wireType)
			}
			m.EndSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndSecond |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsProcessor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsProcessor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsProcessor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSeconds", wireType)
			}
			m.WindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearSeconds", wireType)
			}
			m.ClearSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClearSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresSeconds", wireType)
			}
			m.ExpiresSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointLimit", wireType)
			}
			m.PointLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableProcessMetrics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableProcessMetrics = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessMetricsSeconds", wireType)
			}
			m.ProcessMetricsSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessMetricsSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistogramBuckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistogramBuckets = append(m.HistogramBuckets, HistogramBucket{})
			if err := m.HistogramBuckets[len(m.HistogramBuckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelIgnores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelIgnores = append(m.LabelIgnores, LabelIgnore{})
			if err := m.LabelIgnores[len(m.LabelIgnores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCodeAsException", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetCodeAsException = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondGranularitys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondGranularitys = append(m.SecondGranularitys, SecondGranularity{})
			if err := m.SecondGranularitys[len(m.SecondGranularitys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleMonitors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleMonitors = append(m.SampleMonitors, SampleMonitor{})
			if err := m.SampleMonitors[len(m.SampleMonitors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHasTwoIps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcHasTwoIps = append(m.RpcHasTwoIps, RPCHasTwoIP{})
			if err := m.RpcHasTwoIps[len(m.RpcHasTwoIps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsExporter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsExporter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsExporter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadCount", wireType)
			}
			m.ThreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutMs", wireType)
			}
			m.TimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutMs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSeconds", wireType)
			}
			m.WindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetryCount", wireType)
			}
			m.MaxRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportToFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExportToFile = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrometheusPushConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrometheusPushConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrometheusPushConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Job = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseBasicAuth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseBasicAuth = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grouping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Grouping == nil {
				m.Grouping = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOcp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOcp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOcp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOcp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthOcp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthOcp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOcp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOcp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Grouping[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpHeaders == nil {
				m.HttpHeaders = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOcp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOcp
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthOcp
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOcp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthOcp
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthOcp
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOcp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthOcp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HttpHeaders[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenTelemetryPushConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenTelemetryPushConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenTelemetryPushConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistogramBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistogramBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistogramBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Buckets = append(m.Buckets, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOcp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOcp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Buckets) == 0 {
					m.Buckets = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Buckets = append(m.Buckets, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Processor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exporter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableSse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracesProcessor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracesProcessor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracesProcessor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sampler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sampler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableTraceBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableTraceBody = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDeferredSample", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDeferredSample = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferredSampleError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeferredSampleError = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeferredSampleSlowDurationMs", wireType)
			}
			m.DeferredSampleSlowDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeferredSampleSlowDurationMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableParentSampling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableParentSampling = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowSampler", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WorkflowSampler.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableProfile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableProfile = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableStreamTraceBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableStreamTraceBody = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TracesExporter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TracesExporter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TracesExporter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSeconds", wireType)
			}
			m.WindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSize", wireType)
			}
			m.PacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportToFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExportToFile = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Processor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exporter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsProcessor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsProcessor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsProcessor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyTraceLog", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyTraceLog = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceLogMode", wireType)
			}
			m.TraceLogMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceLogMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableRecovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableRecovery = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MustLogTraced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MustLogTraced = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTracedType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogTracedType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsExporter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsExporter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsExporter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowSeconds", wireType)
			}
			m.WindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WindowSeconds |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketSize", wireType)
			}
			m.PacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PacketSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportToFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExportToFile = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfilesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Processor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exporter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Exporter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfilesProcessor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilesProcessor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilesProcessor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileTypes = append(m.ProfileTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodSeconds", wireType)
			}
			m.PeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuDurationSeconds", wireType)
			}
			m.CpuDurationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuDurationSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuProfileRate", wireType)
			}
			m.CpuProfileRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuProfileRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutexProfileFraction", wireType)
			}
			m.MutexProfileFraction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MutexProfileFraction |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockProfileRate", wireType)
			}
			m.BlockProfileRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockProfileRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDeltaProfiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDeltaProfiles = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableLinkTrace", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableLinkTrace = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfilesExporter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilesExporter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilesExporter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutMs", wireType)
			}
			m.TimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutMs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetryCount", wireType)
			}
			m.MaxRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportToFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExportToFile = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SamplerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SamplerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SamplerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fraction = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorFraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ErrorFraction = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dyeing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dyeing = append(m.Dyeing, Dyeing{})
			if err := m.Dyeing[len(m.Dyeing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableDyeing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableDyeing = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableMinSample", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableMinSample = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableBloomDyeing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableBloomDyeing = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BloomDyeing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BloomDyeing = append(m.BloomDyeing, BloomDyeing{})
			if err := m.BloomDyeing[len(m.BloomDyeing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RateLimit = append(m.RateLimit, &TokenBucketConfig{})
			if err := m.RateLimit[len(m.RateLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Client.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowSamplerConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowSamplerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowSamplerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleCountPerMinute", wireType)
			}
			m.SampleCountPerMinute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleCountPerMinute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCountPerMinute", wireType)
			}
			m.MaxCountPerMinute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCountPerMinute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathMaxCount", wireType)
			}
			m.PathMaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathMaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LifetimeSec", wireType)
			}
			m.LifetimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LifetimeSec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenBucketConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenBucketConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenBucketConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Strategy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Burst", wireType)
			}
			m.Burst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Burst |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dyeing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dyeing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dyeing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrameCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdbId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmdbId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetType", wireType)
			}
			m.TargetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SdkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminPort", wireType)
			}
			m.AdminPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetrySchemaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetrySchemaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetrySchemaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			m.SerialNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SerialNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricSchemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricSchemas = append(m.MetricSchemas, MetricSchema{})
			if err := m.MetricSchemas[len(m.MetricSchemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceSchemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceSchemas = append(m.TraceSchemas, TraceSchema{})
			if err := m.TraceSchemas[len(m.TraceSchemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSchemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSchemas = append(m.LogSchemas, LogSchema{})
			if err := m.LogSchemas[len(m.LogSchemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileSchemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileSchemas = append(m.ProfileSchemas, ProfileSchema{})
			if err := m.ProfileSchemas[len(m.ProfileSchemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelemetrySchemaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetrySchemaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetrySchemaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BloomDyeing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BloomDyeing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BloomDyeing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitSize", wireType)
			}
			m.BitSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BitSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashNumber", wireType)
			}
			m.HashNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Bitmap = append(m.Bitmap, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOcp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOcp
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOcp
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Bitmap) == 0 {
					m.Bitmap = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOcp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Bitmap = append(m.Bitmap, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitmap", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcSamplingConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcSamplingConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcSamplingConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fraction = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rpc = append(m.Rpc, RpcConfig{})
			if err := m.Rpc[len(m.Rpc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fraction", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fraction = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipOcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOcp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOcp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOcp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOcp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOcp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOcp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOcp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOcp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOcp = fmt.Errorf("proto: unexpected end of group")
)
