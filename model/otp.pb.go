// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: otp.proto

package model

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Metrics 全部指标，唯一会发送给 metrics collector 的数据包。
type Metrics struct {
	TimestampMs   int64               `protobuf:"varint,1,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
	NormalLabels  *NormalLabels       `protobuf:"bytes,2,opt,name=normal_labels,json=normalLabels,proto3" json:"normal_labels,omitempty"`
	ClientMetrics []*ClientMetricsOTP `protobuf:"bytes,3,rep,name=client_metrics,json=clientMetrics,proto3" json:"client_metrics,omitempty"`
	ServerMetrics []*ServerMetricsOTP `protobuf:"bytes,4,rep,name=server_metrics,json=serverMetrics,proto3" json:"server_metrics,omitempty"`
	NormalMetrics []*NormalMetricOTP  `protobuf:"bytes,5,rep,name=normal_metrics,json=normalMetrics,proto3" json:"normal_metrics,omitempty"`
	CustomMetrics []*CustomMetricsOTP `protobuf:"bytes,6,rep,name=custom_metrics,json=customMetrics,proto3" json:"custom_metrics,omitempty"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{0}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

func (m *Metrics) GetNormalLabels() *NormalLabels {
	if m != nil {
		return m.NormalLabels
	}
	return nil
}

func (m *Metrics) GetClientMetrics() []*ClientMetricsOTP {
	if m != nil {
		return m.ClientMetrics
	}
	return nil
}

func (m *Metrics) GetServerMetrics() []*ServerMetricsOTP {
	if m != nil {
		return m.ServerMetrics
	}
	return nil
}

func (m *Metrics) GetNormalMetrics() []*NormalMetricOTP {
	if m != nil {
		return m.NormalMetrics
	}
	return nil
}

func (m *Metrics) GetCustomMetrics() []*CustomMetricsOTP {
	if m != nil {
		return m.CustomMetrics
	}
	return nil
}

// Bucket 直方图的桶
type Bucket struct {
	Range string `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Count int64  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *Bucket) Reset()         { *m = Bucket{} }
func (m *Bucket) String() string { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()    {}
func (*Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{1}
}
func (m *Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bucket.Merge(m, src)
}
func (m *Bucket) XXX_Size() int {
	return m.Size()
}
func (m *Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Bucket proto.InternalMessageInfo

func (m *Bucket) GetRange() string {
	if m != nil {
		return m.Range
	}
	return ""
}

func (m *Bucket) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// Histogram 直方图统计指标。
// histogram 指标，实际存储时是 3 个指标：
// {name}_sum
// {name}_count
// {name}_bucket{le=""}
type Histogram struct {
	Sum     float64   `protobuf:"fixed64,1,opt,name=sum,proto3" json:"sum,omitempty"`
	Count   int64     `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Buckets []*Bucket `protobuf:"bytes,3,rep,name=buckets,proto3" json:"buckets,omitempty"`
}

func (m *Histogram) Reset()         { *m = Histogram{} }
func (m *Histogram) String() string { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()    {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{2}
}
func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return m.Size()
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

func (m *Histogram) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Histogram) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Histogram) GetBuckets() []*Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

// Avg 平均值指标，实际存储的时候是 2 个指标
// {name}_sum
// {name}_count
// 是写入时处理的，此处的 name 里面不需要带上_sum, _count。
type Avg struct {
	Sum   float64 `protobuf:"fixed64,1,opt,name=sum,proto3" json:"sum,omitempty"`
	Count int64   `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *Avg) Reset()         { *m = Avg{} }
func (m *Avg) String() string { return proto.CompactTextString(m) }
func (*Avg) ProtoMessage()    {}
func (*Avg) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{3}
}
func (m *Avg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Avg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Avg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Avg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Avg.Merge(m, src)
}
func (m *Avg) XXX_Size() int {
	return m.Size()
}
func (m *Avg) XXX_DiscardUnknown() {
	xxx_messageInfo_Avg.DiscardUnknown(m)
}

var xxx_messageInfo_Avg proto.InternalMessageInfo

func (m *Avg) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Avg) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// MetricOTP otp 协议所用的指标。
type MetricOTP struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to V:
	//	*MetricOTP_Value
	//	*MetricOTP_Avg
	//	*MetricOTP_Histogram
	V           isMetricOTP_V `protobuf_oneof:"v"`
	Aggregation Aggregation   `protobuf:"varint,5,opt,name=aggregation,proto3,enum=model.Aggregation" json:"aggregation,omitempty"`
}

func (m *MetricOTP) Reset()         { *m = MetricOTP{} }
func (m *MetricOTP) String() string { return proto.CompactTextString(m) }
func (*MetricOTP) ProtoMessage()    {}
func (*MetricOTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{4}
}
func (m *MetricOTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricOTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricOTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricOTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricOTP.Merge(m, src)
}
func (m *MetricOTP) XXX_Size() int {
	return m.Size()
}
func (m *MetricOTP) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricOTP.DiscardUnknown(m)
}

var xxx_messageInfo_MetricOTP proto.InternalMessageInfo

type isMetricOTP_V interface {
	isMetricOTP_V()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MetricOTP_Value struct {
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3,oneof" json:"value,omitempty"`
}
type MetricOTP_Avg struct {
	Avg *Avg `protobuf:"bytes,3,opt,name=avg,proto3,oneof" json:"avg,omitempty"`
}
type MetricOTP_Histogram struct {
	Histogram *Histogram `protobuf:"bytes,4,opt,name=histogram,proto3,oneof" json:"histogram,omitempty"`
}

func (*MetricOTP_Value) isMetricOTP_V()     {}
func (*MetricOTP_Avg) isMetricOTP_V()       {}
func (*MetricOTP_Histogram) isMetricOTP_V() {}

func (m *MetricOTP) GetV() isMetricOTP_V {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *MetricOTP) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricOTP) GetValue() float64 {
	if x, ok := m.GetV().(*MetricOTP_Value); ok {
		return x.Value
	}
	return 0
}

func (m *MetricOTP) GetAvg() *Avg {
	if x, ok := m.GetV().(*MetricOTP_Avg); ok {
		return x.Avg
	}
	return nil
}

func (m *MetricOTP) GetHistogram() *Histogram {
	if x, ok := m.GetV().(*MetricOTP_Histogram); ok {
		return x.Histogram
	}
	return nil
}

func (m *MetricOTP) GetAggregation() Aggregation {
	if m != nil {
		return m.Aggregation
	}
	return Aggregation_AGGREGATION_NONE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MetricOTP) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MetricOTP_Value)(nil),
		(*MetricOTP_Avg)(nil),
		(*MetricOTP_Histogram)(nil),
	}
}

// ClientMetricsOTP otp 协议客户端上报指标。
type ClientMetricsOTP struct {
	RpcClientStartedTotal   int64      `protobuf:"varint,1,opt,name=rpc_client_started_total,json=rpcClientStartedTotal,proto3" json:"rpc_client_started_total,omitempty"`
	RpcClientHandledTotal   int64      `protobuf:"varint,2,opt,name=rpc_client_handled_total,json=rpcClientHandledTotal,proto3" json:"rpc_client_handled_total,omitempty"`
	RpcClientHandledSeconds *Histogram `protobuf:"bytes,3,opt,name=rpc_client_handled_seconds,json=rpcClientHandledSeconds,proto3" json:"rpc_client_handled_seconds,omitempty"`
	RpcLabels               *RPCLabels `protobuf:"bytes,4,opt,name=rpc_labels,json=rpcLabels,proto3" json:"rpc_labels,omitempty"`
}

func (m *ClientMetricsOTP) Reset()         { *m = ClientMetricsOTP{} }
func (m *ClientMetricsOTP) String() string { return proto.CompactTextString(m) }
func (*ClientMetricsOTP) ProtoMessage()    {}
func (*ClientMetricsOTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{5}
}
func (m *ClientMetricsOTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientMetricsOTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientMetricsOTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientMetricsOTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientMetricsOTP.Merge(m, src)
}
func (m *ClientMetricsOTP) XXX_Size() int {
	return m.Size()
}
func (m *ClientMetricsOTP) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientMetricsOTP.DiscardUnknown(m)
}

var xxx_messageInfo_ClientMetricsOTP proto.InternalMessageInfo

func (m *ClientMetricsOTP) GetRpcClientStartedTotal() int64 {
	if m != nil {
		return m.RpcClientStartedTotal
	}
	return 0
}

func (m *ClientMetricsOTP) GetRpcClientHandledTotal() int64 {
	if m != nil {
		return m.RpcClientHandledTotal
	}
	return 0
}

func (m *ClientMetricsOTP) GetRpcClientHandledSeconds() *Histogram {
	if m != nil {
		return m.RpcClientHandledSeconds
	}
	return nil
}

func (m *ClientMetricsOTP) GetRpcLabels() *RPCLabels {
	if m != nil {
		return m.RpcLabels
	}
	return nil
}

// ServerMetricsOTP otp 协议服务端上报指标。
type ServerMetricsOTP struct {
	RpcServerStartedTotal   int64      `protobuf:"varint,1,opt,name=rpc_server_started_total,json=rpcServerStartedTotal,proto3" json:"rpc_server_started_total,omitempty"`
	RpcServerHandledTotal   int64      `protobuf:"varint,2,opt,name=rpc_server_handled_total,json=rpcServerHandledTotal,proto3" json:"rpc_server_handled_total,omitempty"`
	RpcServerHandledSeconds *Histogram `protobuf:"bytes,3,opt,name=rpc_server_handled_seconds,json=rpcServerHandledSeconds,proto3" json:"rpc_server_handled_seconds,omitempty"`
	RpcLabels               *RPCLabels `protobuf:"bytes,4,opt,name=rpc_labels,json=rpcLabels,proto3" json:"rpc_labels,omitempty"`
}

func (m *ServerMetricsOTP) Reset()         { *m = ServerMetricsOTP{} }
func (m *ServerMetricsOTP) String() string { return proto.CompactTextString(m) }
func (*ServerMetricsOTP) ProtoMessage()    {}
func (*ServerMetricsOTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{6}
}
func (m *ServerMetricsOTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerMetricsOTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerMetricsOTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerMetricsOTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerMetricsOTP.Merge(m, src)
}
func (m *ServerMetricsOTP) XXX_Size() int {
	return m.Size()
}
func (m *ServerMetricsOTP) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerMetricsOTP.DiscardUnknown(m)
}

var xxx_messageInfo_ServerMetricsOTP proto.InternalMessageInfo

func (m *ServerMetricsOTP) GetRpcServerStartedTotal() int64 {
	if m != nil {
		return m.RpcServerStartedTotal
	}
	return 0
}

func (m *ServerMetricsOTP) GetRpcServerHandledTotal() int64 {
	if m != nil {
		return m.RpcServerHandledTotal
	}
	return 0
}

func (m *ServerMetricsOTP) GetRpcServerHandledSeconds() *Histogram {
	if m != nil {
		return m.RpcServerHandledSeconds
	}
	return nil
}

func (m *ServerMetricsOTP) GetRpcLabels() *RPCLabels {
	if m != nil {
		return m.RpcLabels
	}
	return nil
}

// NormalMetricOTP otp 协议一般指标。
type NormalMetricOTP struct {
	Metric *MetricOTP `protobuf:"bytes,1,opt,name=metric,proto3" json:"metric,omitempty"`
}

func (m *NormalMetricOTP) Reset()         { *m = NormalMetricOTP{} }
func (m *NormalMetricOTP) String() string { return proto.CompactTextString(m) }
func (*NormalMetricOTP) ProtoMessage()    {}
func (*NormalMetricOTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{7}
}
func (m *NormalMetricOTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NormalMetricOTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NormalMetricOTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NormalMetricOTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NormalMetricOTP.Merge(m, src)
}
func (m *NormalMetricOTP) XXX_Size() int {
	return m.Size()
}
func (m *NormalMetricOTP) XXX_DiscardUnknown() {
	xxx_messageInfo_NormalMetricOTP.DiscardUnknown(m)
}

var xxx_messageInfo_NormalMetricOTP proto.InternalMessageInfo

func (m *NormalMetricOTP) GetMetric() *MetricOTP {
	if m != nil {
		return m.Metric
	}
	return nil
}

// CustomMetricOTP otp 协议自定义指标。与 NormalMetricOTP 的区别是，多了
// custom_labels。
type CustomMetricsOTP struct {
	Metrics []*MetricOTP `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
	// CustomLabels 中的第一个字段是 _group，用来拼接出 007 的监控项名，保持兼容性。
	// 007 监控项名为 metrics_name=pp_trc_$app.$server_$_group。
	// pp_trc_$app.$server_ 前缀由后台来拼接加上。
	// 使用下划线开头，避免与用户标签冲突。
	CustomLabels []*Label `protobuf:"bytes,2,rep,name=custom_labels,json=customLabels,proto3" json:"custom_labels,omitempty"`
	// 监控项名
	MonitorName string `protobuf:"bytes,3,opt,name=monitor_name,json=monitorName,proto3" json:"monitor_name,omitempty"`
}

func (m *CustomMetricsOTP) Reset()         { *m = CustomMetricsOTP{} }
func (m *CustomMetricsOTP) String() string { return proto.CompactTextString(m) }
func (*CustomMetricsOTP) ProtoMessage()    {}
func (*CustomMetricsOTP) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{8}
}
func (m *CustomMetricsOTP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomMetricsOTP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CustomMetricsOTP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CustomMetricsOTP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomMetricsOTP.Merge(m, src)
}
func (m *CustomMetricsOTP) XXX_Size() int {
	return m.Size()
}
func (m *CustomMetricsOTP) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomMetricsOTP.DiscardUnknown(m)
}

var xxx_messageInfo_CustomMetricsOTP proto.InternalMessageInfo

func (m *CustomMetricsOTP) GetMetrics() []*MetricOTP {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *CustomMetricsOTP) GetCustomLabels() []*Label {
	if m != nil {
		return m.CustomLabels
	}
	return nil
}

func (m *CustomMetricsOTP) GetMonitorName() string {
	if m != nil {
		return m.MonitorName
	}
	return ""
}

// MultiTargetMetrics 多服务指标合集（不同 NormalLabels 指标合集）。
type MultiTargetMetrics struct {
	Metrics []*Metrics `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (m *MultiTargetMetrics) Reset()         { *m = MultiTargetMetrics{} }
func (m *MultiTargetMetrics) String() string { return proto.CompactTextString(m) }
func (*MultiTargetMetrics) ProtoMessage()    {}
func (*MultiTargetMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{9}
}
func (m *MultiTargetMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiTargetMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiTargetMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiTargetMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiTargetMetrics.Merge(m, src)
}
func (m *MultiTargetMetrics) XXX_Size() int {
	return m.Size()
}
func (m *MultiTargetMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiTargetMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_MultiTargetMetrics proto.InternalMessageInfo

func (m *MultiTargetMetrics) GetMetrics() []*Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// ProfilesBatch 性能数据集合，
// 通常一个采集周期采集的所有类型 profile 数据，放到一个 batch 里。
type ProfilesBatch struct {
	// batch 的序列编号
	Sequence int64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// batch 的开始时间
	Start int64 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	// batch 结束时间
	End int64 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	// batch 包含的所有类型的 profile 数据
	Profiles []*Profile `protobuf:"bytes,4,rep,name=profiles,proto3" json:"profiles,omitempty"`
	// 对应 resource 信息
	Resource *Resource `protobuf:"bytes,5,opt,name=resource,proto3" json:"resource,omitempty"`
}

func (m *ProfilesBatch) Reset()         { *m = ProfilesBatch{} }
func (m *ProfilesBatch) String() string { return proto.CompactTextString(m) }
func (*ProfilesBatch) ProtoMessage()    {}
func (*ProfilesBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{10}
}
func (m *ProfilesBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfilesBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProfilesBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProfilesBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfilesBatch.Merge(m, src)
}
func (m *ProfilesBatch) XXX_Size() int {
	return m.Size()
}
func (m *ProfilesBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfilesBatch.DiscardUnknown(m)
}

var xxx_messageInfo_ProfilesBatch proto.InternalMessageInfo

func (m *ProfilesBatch) GetSequence() int64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *ProfilesBatch) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ProfilesBatch) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *ProfilesBatch) GetProfiles() []*Profile {
	if m != nil {
		return m.Profiles
	}
	return nil
}

func (m *ProfilesBatch) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

// Profile 性能数据
type Profile struct {
	// profile 名称，如 cpu.pprof、delta-heap.pprof 等。
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// profile 类型，如 cpu、heap、mutex 等。
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// profiles 数据，内容为 https://github.com/google/pprof/blob/main/proto/profile.proto。
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}
func (*Profile) Descriptor() ([]byte, []int) {
	return fileDescriptor_54a06e9d3d924ad8, []int{11}
}
func (m *Profile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Profile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Profile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Profile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Profile.Merge(m, src)
}
func (m *Profile) XXX_Size() int {
	return m.Size()
}
func (m *Profile) XXX_DiscardUnknown() {
	xxx_messageInfo_Profile.DiscardUnknown(m)
}

var xxx_messageInfo_Profile proto.InternalMessageInfo

func (m *Profile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Profile) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Profile) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Metrics)(nil), "model.Metrics")
	proto.RegisterType((*Bucket)(nil), "model.Bucket")
	proto.RegisterType((*Histogram)(nil), "model.Histogram")
	proto.RegisterType((*Avg)(nil), "model.Avg")
	proto.RegisterType((*MetricOTP)(nil), "model.MetricOTP")
	proto.RegisterType((*ClientMetricsOTP)(nil), "model.ClientMetricsOTP")
	proto.RegisterType((*ServerMetricsOTP)(nil), "model.ServerMetricsOTP")
	proto.RegisterType((*NormalMetricOTP)(nil), "model.NormalMetricOTP")
	proto.RegisterType((*CustomMetricsOTP)(nil), "model.CustomMetricsOTP")
	proto.RegisterType((*MultiTargetMetrics)(nil), "model.MultiTargetMetrics")
	proto.RegisterType((*ProfilesBatch)(nil), "model.ProfilesBatch")
	proto.RegisterType((*Profile)(nil), "model.Profile")
}

func init() { proto.RegisterFile("otp.proto", fileDescriptor_54a06e9d3d924ad8) }

var fileDescriptor_54a06e9d3d924ad8 = []byte{
	// 811 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcf, 0x6e, 0xfb, 0x44,
	0x10, 0x8e, 0xe3, 0xfc, 0xa9, 0x27, 0x7f, 0x7e, 0xd1, 0x52, 0xda, 0x90, 0x43, 0x94, 0xfa, 0x42,
	0x54, 0x44, 0x0a, 0xa1, 0x12, 0x08, 0x44, 0xa5, 0xa6, 0x42, 0xca, 0x81, 0x94, 0x6a, 0xdb, 0x13,
	0x42, 0x8a, 0xb6, 0xce, 0xe2, 0x5a, 0xd8, 0x5e, 0xb3, 0xbb, 0x8e, 0xc4, 0x9d, 0x07, 0xe0, 0xc0,
	0x63, 0xf0, 0x18, 0x1c, 0x38, 0xf6, 0xc8, 0x11, 0xb5, 0xe2, 0x3d, 0x90, 0x77, 0xd7, 0x4e, 0xe2,
	0xa6, 0x52, 0xc5, 0x6d, 0x76, 0xbe, 0xf9, 0xc6, 0xdf, 0x7e, 0xd9, 0x99, 0x80, 0xc3, 0x64, 0x32,
	0x49, 0x38, 0x93, 0x0c, 0xd5, 0x23, 0xb6, 0xa2, 0xe1, 0xe0, 0xd0, 0x67, 0x3e, 0x53, 0x99, 0xb3,
	0x2c, 0xd2, 0xe0, 0xc0, 0x61, 0x51, 0x52, 0x84, 0x9e, 0x09, 0xdd, 0x7f, 0xab, 0xd0, 0x5c, 0x50,
	0xc9, 0x03, 0x4f, 0xa0, 0x13, 0x68, 0xcb, 0x20, 0xa2, 0x42, 0x92, 0x28, 0x59, 0x46, 0xa2, 0x6f,
	0x8d, 0xac, 0xb1, 0x8d, 0x5b, 0x45, 0x6e, 0x21, 0xd0, 0x17, 0xd0, 0x89, 0x19, 0x8f, 0x48, 0xb8,
	0x0c, 0xc9, 0x3d, 0x0d, 0x45, 0xbf, 0x3a, 0xb2, 0xc6, 0xad, 0xe9, 0x7b, 0x13, 0xf5, 0xe5, 0xc9,
	0xb5, 0xc2, 0xbe, 0x55, 0x10, 0x6e, 0xc7, 0x5b, 0x27, 0x74, 0x01, 0x5d, 0x2f, 0x0c, 0x68, 0x2c,
	0x97, 0x91, 0xfe, 0x5c, 0xdf, 0x1e, 0xd9, 0xe3, 0xd6, 0xf4, 0xd8, 0x50, 0xaf, 0x14, 0x68, 0xa4,
	0x7c, 0x77, 0x77, 0x83, 0x3b, 0xde, 0x76, 0x26, 0xe3, 0x0b, 0xca, 0xd7, 0x94, 0x17, 0xfc, 0xda,
	0x0e, 0xff, 0x56, 0x81, 0xdb, 0x7c, 0xb1, 0x9d, 0x41, 0x5f, 0x43, 0xd7, 0x28, 0xcf, 0xf9, 0x75,
	0xc5, 0x3f, 0xda, 0x91, 0xae, 0xab, 0x15, 0x3d, 0xde, 0x4a, 0x68, 0xf9, 0xa9, 0x90, 0x2c, 0x2a,
	0xe8, 0x8d, 0x5d, 0xf9, 0x0a, 0xdc, 0x91, 0xbf, 0x9d, 0x71, 0xcf, 0xa1, 0x31, 0x4b, 0xbd, 0x9f,
	0xa8, 0x44, 0x87, 0x50, 0xe7, 0x24, 0xf6, 0xa9, 0xb2, 0xd7, 0xc1, 0xfa, 0x90, 0x65, 0x3d, 0x96,
	0xc6, 0x52, 0x19, 0x6a, 0x63, 0x7d, 0x70, 0x7f, 0x00, 0x67, 0x1e, 0x08, 0xc9, 0x7c, 0x4e, 0x22,
	0xd4, 0x03, 0x5b, 0xa4, 0x91, 0xa2, 0x59, 0x38, 0x0b, 0xf7, 0x93, 0xd0, 0x87, 0xd0, 0xbc, 0x57,
	0x9f, 0xca, 0x2d, 0xee, 0x18, 0x8d, 0x5a, 0x00, 0xce, 0x51, 0xf7, 0x63, 0xb0, 0x2f, 0xd7, 0xfe,
	0x5b, 0xfb, 0xba, 0x7f, 0x5a, 0xe0, 0x14, 0xfe, 0x20, 0x04, 0xb5, 0x98, 0x44, 0xf9, 0x2d, 0x54,
	0x8c, 0x8e, 0xa0, 0xbe, 0x26, 0x61, 0x4a, 0x15, 0xcf, 0x9a, 0x57, 0xb0, 0x3e, 0xa2, 0x21, 0xd8,
	0x64, 0xed, 0xf7, 0x6d, 0xf5, 0x56, 0xc0, 0xa8, 0xb9, 0x5c, 0xfb, 0xf3, 0x0a, 0xce, 0x00, 0xf4,
	0x09, 0x38, 0x0f, 0xf9, 0x35, 0xfb, 0x35, 0x55, 0xd5, 0x33, 0x55, 0xc5, 0xf5, 0xe7, 0x15, 0xbc,
	0x29, 0x42, 0xe7, 0xd0, 0x22, 0xbe, 0xcf, 0xa9, 0x4f, 0x64, 0xc0, 0xe2, 0x7e, 0x7d, 0x64, 0x8d,
	0xbb, 0x53, 0x94, 0x77, 0xde, 0x20, 0x78, 0xbb, 0x6c, 0x66, 0x83, 0xb5, 0x76, 0x7f, 0xad, 0x42,
	0xaf, 0xfc, 0xd8, 0xd0, 0xe7, 0xd0, 0xe7, 0x89, 0xb7, 0x34, 0x2f, 0x54, 0x48, 0xc2, 0x25, 0x5d,
	0x2d, 0x25, 0x93, 0x24, 0x34, 0x63, 0xf0, 0x3e, 0x4f, 0x3c, 0x4d, 0xbb, 0xd5, 0xe8, 0x5d, 0x06,
	0x96, 0x88, 0x0f, 0x24, 0x5e, 0x85, 0x05, 0xb1, 0x5a, 0x22, 0xce, 0x35, 0xaa, 0x89, 0x0b, 0x18,
	0xec, 0x21, 0x0a, 0xea, 0xb1, 0x78, 0x25, 0x8c, 0x55, 0x2f, 0x4c, 0xc0, 0xc7, 0xe5, 0x66, 0xb7,
	0x9a, 0x80, 0xce, 0x00, 0xb2, 0x76, 0x66, 0x2a, 0x77, 0x3d, 0xc4, 0x37, 0x57, 0x66, 0x24, 0x1d,
	0x9e, 0x78, 0x3a, 0x54, 0x36, 0x94, 0x67, 0x26, 0xbf, 0x8d, 0x19, 0xb4, 0xd7, 0x6c, 0xd0, 0xb4,
	0x7d, 0x36, 0x18, 0xe2, 0x6b, 0x36, 0x68, 0xe2, 0x3e, 0x1b, 0x4a, 0xc4, 0xb7, 0xd8, 0xb0, 0xd3,
	0xec, 0x7f, 0xdb, 0xf0, 0x15, 0xbc, 0x2b, 0x4d, 0x3e, 0x1a, 0x43, 0x43, 0xcf, 0xb8, 0xba, 0xf2,
	0x86, 0xbf, 0xd9, 0x0d, 0x06, 0x77, 0x7f, 0xb7, 0xa0, 0x57, 0x1e, 0x7c, 0x74, 0x0a, 0xcd, 0x7c,
	0x45, 0x58, 0x6a, 0xfc, 0x5e, 0xf2, 0xf3, 0x02, 0xf4, 0x29, 0x98, 0x35, 0xb1, 0x59, 0xa7, 0x19,
	0xa3, 0x6d, 0x18, 0x4a, 0x23, 0x6e, 0xeb, 0x12, 0xb3, 0x47, 0x4f, 0xa0, 0x1d, 0xb1, 0x38, 0x90,
	0x8c, 0x2f, 0xd5, 0xfc, 0xd9, 0x6a, 0xfe, 0x5a, 0x26, 0x77, 0x4d, 0x22, 0xea, 0x5e, 0x00, 0x5a,
	0xa4, 0xa1, 0x0c, 0xee, 0x08, 0xf7, 0x69, 0xb1, 0x40, 0xc7, 0x65, 0x5d, 0xdd, 0x1d, 0x5d, 0xa2,
	0x50, 0xe5, 0xfe, 0x61, 0x41, 0xe7, 0x86, 0xb3, 0x1f, 0x83, 0x90, 0x8a, 0x19, 0x91, 0xde, 0x03,
	0x1a, 0xc0, 0x81, 0xa0, 0x3f, 0xa7, 0x34, 0xf6, 0xa8, 0x79, 0x07, 0xc5, 0x39, 0x5b, 0x16, 0xea,
	0xa1, 0xe4, 0xcb, 0x42, 0x1d, 0xb2, 0xa5, 0x42, 0xe3, 0x95, 0x52, 0x67, 0xe3, 0x2c, 0x44, 0xa7,
	0x70, 0x90, 0x98, 0xa6, 0x66, 0x75, 0xe7, 0x02, 0xcc, 0xb7, 0x70, 0x81, 0xa3, 0x8f, 0xe0, 0x80,
	0x53, 0xc1, 0x52, 0xee, 0x51, 0x35, 0xdb, 0xad, 0xe9, 0xbb, 0xfc, 0x47, 0x34, 0x69, 0x5c, 0x14,
	0xb8, 0xdf, 0x40, 0xd3, 0x74, 0xd8, 0xbb, 0x94, 0x10, 0xd4, 0xe4, 0x2f, 0x89, 0xde, 0x49, 0x0e,
	0x56, 0x71, 0x96, 0x5b, 0x11, 0x49, 0x94, 0xbc, 0x36, 0x56, 0xf1, 0xec, 0xcb, 0xbf, 0x9e, 0x86,
	0xd6, 0xe3, 0xd3, 0xd0, 0xfa, 0xe7, 0x69, 0x68, 0xfd, 0xf6, 0x3c, 0xac, 0x3c, 0x3e, 0x0f, 0x2b,
	0x7f, 0x3f, 0x0f, 0x2b, 0xf0, 0x81, 0xc7, 0xa2, 0x89, 0xcc, 0x2e, 0x1b, 0xcb, 0x89, 0x4f, 0xc2,
	0x20, 0xa4, 0xe6, 0x4f, 0xf5, 0x7b, 0xfd, 0x8f, 0x7b, 0xdf, 0x50, 0xa7, 0xcf, 0xfe, 0x0b, 0x00,
	0x00, 0xff, 0xff, 0x55, 0x24, 0xf3, 0x9e, 0x8c, 0x07, 0x00, 0x00,
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomMetrics) > 0 {
		for iNdEx := len(m.CustomMetrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomMetrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.NormalMetrics) > 0 {
		for iNdEx := len(m.NormalMetrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NormalMetrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ServerMetrics) > 0 {
		for iNdEx := len(m.ServerMetrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServerMetrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ClientMetrics) > 0 {
		for iNdEx := len(m.ClientMetrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClientMetrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NormalLabels != nil {
		{
			size, err := m.NormalLabels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TimestampMs != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Range) > 0 {
		i -= len(m.Range)
		copy(dAtA[i:], m.Range)
		i = encodeVarintOtp(dAtA, i, uint64(len(m.Range)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Count != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Sum != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Avg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Avg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Avg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Sum != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MetricOTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Aggregation != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.Aggregation))
		i--
		dAtA[i] = 0x28
	}
	if m.V != nil {
		{
			size := m.V.Size()
			i -= size
			if _, err := m.V.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOtp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricOTP_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricOTP_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func (m *MetricOTP_Avg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricOTP_Avg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Avg != nil {
		{
			size, err := m.Avg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MetricOTP_Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricOTP_Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Histogram != nil {
		{
			size, err := m.Histogram.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ClientMetricsOTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientMetricsOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientMetricsOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RpcLabels != nil {
		{
			size, err := m.RpcLabels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RpcClientHandledSeconds != nil {
		{
			size, err := m.RpcClientHandledSeconds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RpcClientHandledTotal != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.RpcClientHandledTotal))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcClientStartedTotal != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.RpcClientStartedTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServerMetricsOTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerMetricsOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerMetricsOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RpcLabels != nil {
		{
			size, err := m.RpcLabels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RpcServerHandledSeconds != nil {
		{
			size, err := m.RpcServerHandledSeconds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RpcServerHandledTotal != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.RpcServerHandledTotal))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcServerStartedTotal != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.RpcServerStartedTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NormalMetricOTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NormalMetricOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NormalMetricOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metric != nil {
		{
			size, err := m.Metric.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CustomMetricsOTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomMetricsOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomMetricsOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MonitorName) > 0 {
		i -= len(m.MonitorName)
		copy(dAtA[i:], m.MonitorName)
		i = encodeVarintOtp(dAtA, i, uint64(len(m.MonitorName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CustomLabels) > 0 {
		for iNdEx := len(m.CustomLabels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomLabels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MultiTargetMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiTargetMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiTargetMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProfilesBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilesBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProfilesBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOtp(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Profiles) > 0 {
		for iNdEx := len(m.Profiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Profiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOtp(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.End != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Start != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x10
	}
	if m.Sequence != 0 {
		i = encodeVarintOtp(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Profile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintOtp(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintOtp(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOtp(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOtp(dAtA []byte, offset int, v uint64) int {
	offset -= sovOtp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimestampMs != 0 {
		n += 1 + sovOtp(uint64(m.TimestampMs))
	}
	if m.NormalLabels != nil {
		l = m.NormalLabels.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	if len(m.ClientMetrics) > 0 {
		for _, e := range m.ClientMetrics {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	if len(m.ServerMetrics) > 0 {
		for _, e := range m.ServerMetrics {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	if len(m.NormalMetrics) > 0 {
		for _, e := range m.NormalMetrics {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	if len(m.CustomMetrics) > 0 {
		for _, e := range m.CustomMetrics {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	return n
}

func (m *Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Range)
	if l > 0 {
		n += 1 + l + sovOtp(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovOtp(uint64(m.Count))
	}
	return n
}

func (m *Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != 0 {
		n += 9
	}
	if m.Count != 0 {
		n += 1 + sovOtp(uint64(m.Count))
	}
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	return n
}

func (m *Avg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != 0 {
		n += 9
	}
	if m.Count != 0 {
		n += 1 + sovOtp(uint64(m.Count))
	}
	return n
}

func (m *MetricOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOtp(uint64(l))
	}
	if m.V != nil {
		n += m.V.Size()
	}
	if m.Aggregation != 0 {
		n += 1 + sovOtp(uint64(m.Aggregation))
	}
	return n
}

func (m *MetricOTP_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *MetricOTP_Avg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Avg != nil {
		l = m.Avg.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}
func (m *MetricOTP_Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Histogram != nil {
		l = m.Histogram.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}
func (m *ClientMetricsOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcClientStartedTotal != 0 {
		n += 1 + sovOtp(uint64(m.RpcClientStartedTotal))
	}
	if m.RpcClientHandledTotal != 0 {
		n += 1 + sovOtp(uint64(m.RpcClientHandledTotal))
	}
	if m.RpcClientHandledSeconds != nil {
		l = m.RpcClientHandledSeconds.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	if m.RpcLabels != nil {
		l = m.RpcLabels.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}

func (m *ServerMetricsOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcServerStartedTotal != 0 {
		n += 1 + sovOtp(uint64(m.RpcServerStartedTotal))
	}
	if m.RpcServerHandledTotal != 0 {
		n += 1 + sovOtp(uint64(m.RpcServerHandledTotal))
	}
	if m.RpcServerHandledSeconds != nil {
		l = m.RpcServerHandledSeconds.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	if m.RpcLabels != nil {
		l = m.RpcLabels.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}

func (m *NormalMetricOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}

func (m *CustomMetricsOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	if len(m.CustomLabels) > 0 {
		for _, e := range m.CustomLabels {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	l = len(m.MonitorName)
	if l > 0 {
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}

func (m *MultiTargetMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	return n
}

func (m *ProfilesBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovOtp(uint64(m.Sequence))
	}
	if m.Start != 0 {
		n += 1 + sovOtp(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovOtp(uint64(m.End))
	}
	if len(m.Profiles) > 0 {
		for _, e := range m.Profiles {
			l = e.Size()
			n += 1 + l + sovOtp(uint64(l))
		}
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}

func (m *Profile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOtp(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOtp(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovOtp(uint64(l))
	}
	return n
}

func sovOtp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOtp(x uint64) (n int) {
	return sovOtp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NormalLabels == nil {
				m.NormalLabels = &NormalLabels{}
			}
			if err := m.NormalLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientMetrics = append(m.ClientMetrics, &ClientMetricsOTP{})
			if err := m.ClientMetrics[len(m.ClientMetrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerMetrics = append(m.ServerMetrics, &ServerMetricsOTP{})
			if err := m.ServerMetrics[len(m.ServerMetrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NormalMetrics = append(m.NormalMetrics, &NormalMetricOTP{})
			if err := m.NormalMetrics[len(m.NormalMetrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomMetrics = append(m.CustomMetrics, &CustomMetricsOTP{})
			if err := m.CustomMetrics[len(m.CustomMetrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Range = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &Bucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Avg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Avg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Avg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricOTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricOTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricOTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.V = &MetricOTP_Value{float64(math.Float64frombits(v))}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Avg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.V = &MetricOTP_Avg{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Histogram{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.V = &MetricOTP_Histogram{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregation", wireType)
			}
			m.Aggregation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aggregation |= Aggregation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientMetricsOTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientMetricsOTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientMetricsOTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcClientStartedTotal", wireType)
			}
			m.RpcClientStartedTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RpcClientStartedTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcClientHandledTotal", wireType)
			}
			m.RpcClientHandledTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RpcClientHandledTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcClientHandledSeconds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcClientHandledSeconds == nil {
				m.RpcClientHandledSeconds = &Histogram{}
			}
			if err := m.RpcClientHandledSeconds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcLabels == nil {
				m.RpcLabels = &RPCLabels{}
			}
			if err := m.RpcLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerMetricsOTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerMetricsOTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerMetricsOTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcServerStartedTotal", wireType)
			}
			m.RpcServerStartedTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RpcServerStartedTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcServerHandledTotal", wireType)
			}
			m.RpcServerHandledTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RpcServerHandledTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcServerHandledSeconds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcServerHandledSeconds == nil {
				m.RpcServerHandledSeconds = &Histogram{}
			}
			if err := m.RpcServerHandledSeconds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcLabels == nil {
				m.RpcLabels = &RPCLabels{}
			}
			if err := m.RpcLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NormalMetricOTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NormalMetricOTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NormalMetricOTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricOTP{}
			}
			if err := m.Metric.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomMetricsOTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomMetricsOTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomMetricsOTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &MetricOTP{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomLabels = append(m.CustomLabels, &Label{})
			if err := m.CustomLabels[len(m.CustomLabels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonitorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiTargetMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiTargetMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiTargetMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfilesBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilesBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilesBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profiles = append(m.Profiles, &Profile{})
			if err := m.Profiles[len(m.Profiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &Resource{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOtp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOtp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOtp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOtp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOtp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOtp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOtp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOtp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOtp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOtp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOtp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOtp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOtp = fmt.Errorf("proto: unexpected end of group")
)
